<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ğŸ¶ ULID Music</title>

  <!-- ThÃ¨me avant chargement du CSS -->
  <script>
    const currentTheme = window.matchMedia("(prefers-color-scheme: dark)").matches;
    document.documentElement.setAttribute("data-theme", currentTheme ? "dark" : "light");
  </script>

  <!-- ton CSS -->
  <link rel="stylesheet" href="/style.css"/>

  <style>

    /* conteneur gÃ©nÃ©rique pour faire 2 colonnes puis 1 colonne */
    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    /* chaque â€œgroupeâ€ fait 1/2 du conteneur, au minimum 250px */
    .group {
      flex: 1 1 45%;
      min-width: 250px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* Media query : < 600px on passe Ã  1 colonne */
    @media (max-width: 600px) {
      .group {
        flex: 1 1 100%;
      }
    }

    /* â”€â”€ Taille fixe pour lâ€™ULID (26 caractÃ¨res Base32) â”€â”€ */
    #ulid-input {
      flex: none;              /* pas dâ€™expansion/shrink */
      width: 28ch;             /* 26 â€œ0â€ de large, soit pile la longueur dâ€™un ULID */
      box-sizing: border-box;  /* inclut padding/border dans ces 26ch */
    }
    
    /* â”€â”€ PrÃ©visualisation date : ne pas rÃ©duire, afficher tout le texte â”€â”€ */
    #ulid-ts-preview {
      flex: none;              /* taille auto selon contenu */
      min-width: max-content;  /* largeur mini = largeur du texte */
    }

    /* Partition : applicables Ã  #staff et staff0..staff3 */
    [id^="staff"] {
      background: var(--bg);
    }

    /* SÃ©lecteur simplifiÃ© : 1-seul Â« match Â» par Ã©lÃ©ment */
    [id^="staff"] svg {
      stroke: var(--text);
      fill:   var(--text);
      max-width: 100%;
      display: block;
    }
    [id^="staff"] .note-play * {
      stroke: var(--heading) !important;
      fill:   var(--heading) !important;
    }

    /* â”€â”€ PartitionÂ : note en cours â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    /* VexFlow baptise les groupes <g> .vf-stavenote â†’ on les colore */
    .note-play path,
    .note-play ellipse {
      fill:   var(--heading) !important;   /* tÃªte de note */
      stroke: var(--heading) !important;   /* hampe / ligature */
    }

    /* â”€â”€ Tableau : pastille Â«â€¯Playingâ€¯Â» â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .playing-col{ text-align:center; vertical-align:middle; }
    .playing-col.playing::before{   /* pastille visible uniquement */
      content: "";
      display: inline-block;
      width:  .75em;
      height: .75em;
      border-radius: 50%;
      background: var(--heading);
      vertical-align:middle;
    }

    /* Miniâ€tables : 4Ã—8 notes */
    .mini table {
      width: 100%;
      border-collapse: collapse;
      font-size:    .85rem;
      margin-top:   .5rem;
    }


    .mini th,
    .mini td {
      color: var(--text);
      padding: 0.2em 0.3em;
      text-align: center;
      vertical-align:  middle;
      line-height: 1.2;
      white-space: normal;
    }

    .mini th .th-wrap {
      white-space: normal;
    }

    /* â”€â”€ Ligne en cours de lecture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .mini tbody tr.playing-row td {
      color: var(--heading) !important;
    }

    .flex-container + .flex-container {
        margin-top: 0.5rem;
      }

    .grid4 {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }

    /* On â€œdÃ©conteneuriseâ€ chaque bloc pour que <table> et <div id="staffX">
       deviennent des items indÃ©pendants de la grille.                     */
    .grid4.stacked > div {
      display: contents;
    }

    /* Chaque portÃ©e doit occuper toute la ligne pour Ãªtre bien lisible */
    .grid4.stacked [id^="staff"] {
      grid-column: 1 / -1;      /* pleine largeur */
      margin-top: .5rem;
      order: 1;                 /* les portÃ©es passent APRÃˆS les tableaux */
    }

    /* Les mini-tableaux restent en 1Ê³áµ‰ ligne, cÃ´te Ã  cÃ´te */
    .grid4.stacked table.mini { order: 0; }

    .grid4 > div {
      min-width: 0;
      max-width: 100%;
      overflow: visible;
      display: flex;
      flex-direction: column;
    }

    .grid4 svg {
      max-width: 100%;
      height: auto;
      display: block;
    }

    /* Responsive â€“ 2 colonnes sous 1024px, 1 colonne sous 600px */
    @media (max-width: 1024px) {
      .grid4 {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 600px) {
      .grid4 {
        grid-template-columns: 1fr;
      }
    }

    .bit-grids label {
      font-weight: bold;
      font-size: 0.9rem;
      margin-top: 0.8rem;
      display: block;
    }

    /* mÃªme hauteur pour toutes les grilles
      (96â€¯px = 12â€¯px dâ€™enâ€‘tÃªte + 4â€¯Ã—â€¯16â€¯px de pilule) */
    .bit-grids svg {
      width: 100%;
      height: 96px;
      margin-bottom: 1rem;
      display: block;
    }

    #note-grids > div {
      min-width: 0;        /* permet aux enfants de shrinker */
      max-width: 100%;     /* empÃªche le dÃ©bordement */
      overflow-x: auto;    /* ajoute un scroll horizontal si vraiment trop large */
    }

    #staff-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .th-wrap {
      display: inline-block;
      white-space: normal;
      line-height: 1.1;
      font-size: 0.75rem;
      text-align: center;
    }

    #ulid-decode {
      margin-top: 1rem;
      text-align: center;
      font-family: monospace;
    }

    .nibble-line {
      display: flex;
      justify-content: center;
      gap: 0.25rem;
      margin: 0.3rem 0;
      flex-wrap: wrap;
    }

    .nibble-line span {
      display: inline-block;
      width: 4ch;
      text-align: center;
    }

  </style>

</head>

<body>

  <header id="nav-container" class="header-nav-container"></header>

  <main class="page-wrapper" role="main">

    <h1>ğŸ¶Â ULIDÂ Music</h1>
    <section id="ulid-controls">
      <div class="action-container flex-container">
        <div class="group">
          <button type="button" id="ulid-now"
                  aria-label="GÃ©nÃ©rer un ULID Ã  lâ€™horodatage courant">
            <span aria-hidden="true">â²ï¸</span> Maintenant
          </button>
          <button type="button" id="ulid-random"
                  aria-label="GÃ©nÃ©rer un ULID alÃ©atoire">
            <span aria-hidden="true">ğŸ²</span> ULID alÃ©atoire
          </button>
        </div>
      </div>
      <div id="ulid-row" class="flex-container">
        <div class="group">
          <label for="ulid-input">ULIDâ€¯:</label>
          <input id="ulid-input" placeholder="26 car. ULID (Crockford)" />
          <div id="ulid-status" style="margin-top:.5rem;"></div>
        </div>
        <div class="group">
          <pre id="ulid-ts-preview" class="code-block ts-preview"
              style="white-space:nowrap; margin-left:0;">
            ğŸ“† Date : â€”  
          </pre>
        </div>
      </div>
    </section>

    <h2>ğŸµ Notes & ğŸ¥ Rythme</h2>
    <label>ğŸªœ Conversion ULID -> Binaire (nibbles) -> Valeur -> Note</label>
    <section id="ulid-decode" class="aligned-decode hidden">
      <div class="nibble-line" id="nibbles-binary"></div>
      <div class="nibble-line" id="nibbles-values"></div>
      <div class="nibble-line" id="nibbles-notes"></div>
    </section>

    <section>
      <div class="bit-grids">
        <label>ğŸ§© Nibbles</label>
        <svg id="nibbles-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits des nibbles ULID"></svg>
        <label>ğŸ” InversÃ©s</label>
        <svg id="reversed-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits des nibbles inversÃ©s"></svg>
        <label>ğŸ§® XOR Nibbles^InversÃ©s</label>
        <svg id="xor-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits XOR nibbles"></svg>
        <label>âš¡ XOR adaptatif b0^b2 ou b1^b3</label>
        <svg id="xor-adaptive" viewBox="0 0 320 16" preserveAspectRatio="none" aria-label="XOR adaptatif"></svg>
      </div>
      <div>
        <pre id="summary" class="code-block" style="white-space:pre-wrap; font-size:.9rem; margin-bottom:1rem;">â€”</pre>
      </div>
    </section>

    <section id="music-controls">
      <h2>ğŸ›ï¸ SonoritÃ©s</h2>
      <div class="flex-container">
        <div class="group">
          <label>Instrument :
            <select id="instrumentSel">
              <option value="piano" selected>Piano</option>
              <option value="marimba">Marimba</option>
              <option value="strings">Cordes</option>
              <option value="synth">SynthÃ©</option>
              <option value="woodwind">Bois</option>
            </select>
          </label>
          <label>Octave :
            <select id="octaveShift">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </label>
        </div>
        <div class="group">
          <label for="tempoBpm">BPM :
            <input type="number" id="tempoBpm" min="20" max="300" step="1" value="75"/>
          </label>
          <label for="tempoDur">DurÃ©e dâ€™une noire (s) :
            <input type="number" id="tempoDur" step="0.01" min="0.2" max="3" value="0.8"/>
          </label>
        </div>
        <div class="group">
          <label>AccordsÂ :
            <select id="chordsSel">
              <option value="none" selected>Aucun</option>
              <option value="power">Quintes (power chord)</option>
              <option value="triad">Triades</option>
              <option value="seventh">SeptiÃ¨mes</option>
            </select>
          </label>
          <label>ArpÃ¨geÂ :
            <select id="arp">
              <option value="none" selected>Aucun</option>
              <option value="up">Montant</option>
              <option value="down">Descendant</option>
              <option value="updown">Montant & descendant</option>
              <option value="random">AlÃ©atoire</option>
            </select>
          </label>
        </div>
      </div>
    </section>

    <section id="player-controls">
      <h2>â–¶ï¸ Lecture</h2>
      <pre id="note-sequence" class="code-block" style="white-space:pre-wrap; font-size:.9rem; margin-bottom:0.5rem;">ğŸµ SÃ©quence :<br> â€”</pre>
      <div class="action-container flex-container">
        <div class="group">
          <button type="button" id="play"  aria-label="Lire la sÃ©quence">
            <span aria-hidden="true">â–¶</span> Jouer
          </button>
          <button type="button" id="pause" aria-label="Mettre la lecture en pause">
            <span aria-hidden="true">â¸</span> Pause
          </button>
          <button type="button" id="stop"  aria-label="ArrÃªter la lecture">
            <span aria-hidden="true">â¹</span> Stop
          </button>
        </div>
      </div>
    </section>

    <h2>ğŸ¼ Visualisation</h2>

    <section>
      <div class="grid4" id="note-grids">
        <!-- rÃ©pÃ©tÃ© 4Ã—Â -->
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouÃ©es</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl0"></tbody></table>
          <div id="staff0"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouÃ©es</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl1"></tbody></table>
          <div id="staff1"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouÃ©es</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl2"></tbody></table>
          <div id="staff2"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouÃ©es</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl3"></tbody></table>
          <div id="staff3"></div>
        </div>
      </div>
    </section>

    <section id="staff-wrapper" class="staff-wrapper"></section>

    <section>
      <h2>ğŸ§  DÃ©marche de gÃ©nÃ©ration</h2>
      <ol style="line-height:1.6">
        <li>
          <strong>ğŸ”¢ ULID â†’ 128 bits â†’ nibbles</strong><br />
          Lâ€™ULID est une chaÃ®ne de 26 caractÃ¨res encodÃ©s en base32 Crockford (5 bits par caractÃ¨re).<br />
          Seuls les <strong>128 premiers bits</strong> (sur les 130 possibles) sont conservÃ©s,
          puis dÃ©coupÃ©s en <strong>32 groupes de 4 bits</strong>, appelÃ©s <em>nibbles</em>.<br />
          Chaque nibble reprÃ©sente une valeur entre 0 et 15.
        </li>
        <li>
          <strong>ğŸµ Note = valeur du nibble</strong><br />
          Chaque valeur est associÃ©e Ã  une note musicale parmi une gamme de <strong>16 notes fixes</strong>,
          ajustÃ©e selon lâ€™octave sÃ©lectionnÃ©e.
        </li>
        <li>
          <strong>ğŸ§® Rythme = XOR adaptatif</strong><br />
          Pour chaque nibble en position <code>i</code>, on calcule :<br />
          â†’ un <strong>XOR</strong> entre sa valeur et celle du nibble symÃ©trique en position
          <code>31 - i</code><br />
          â†’ puis on extrait un seul bit de ce rÃ©sultat selon <code>i</code> :
          <ul>
            <li>Si <code>i</code> est pair â†’ <code>b1 ^ b3</code></li>
            <li>Si <code>i</code> est impair â†’ <code>b0 ^ b2</code></li>
          </ul>
          Ce bit dÃ©termine la durÃ©e :
          <code>0</code> â†’ <strong>croche</strong> (1/8) â€¢ <code>1</code> â†’ <strong>double-croche</strong> (1/16)
        </li>
        <li>
          <strong>ğŸ“Š Statistiques rythmiques</strong><br />
          Un encart rÃ©capitule :
          <ul>
            <li>â±ï¸ la durÃ©e totale estimÃ©e</li>
            <li>ğŸ¼ le nombre total de battements</li>
            <li>âš–ï¸ la rÃ©partition rapide / lente</li>
          </ul>
        </li>
        <li>
          <strong>ğŸ¼ Visualisation</strong><br />
          Chaque note est affichÃ©e :
          <ul>
            <li>ğŸ“‹ dans un tableau (avec valeur, durÃ©e, accord, arpÃ¨ge)</li>
            <li>ğŸ¶ sur une portÃ©e (clef et durÃ©e rÃ©elle, via VexFlow)</li>
          </ul>
          Les notes sont groupÃ©es par blocs de 8, et les portÃ©es sâ€™adaptent automatiquement Ã  leur densitÃ©.
        </li>
        <li>
          <strong>â–¶ï¸ Lecture musicale</strong><br />
          La lecture dÃ©clenche :
          <ul>
            <li>ğŸ”ˆ la lecture audio synchronisÃ©e</li>
            <li>ğŸ“š la surbrillance temps rÃ©el des notes</li>
            <li>ğŸ§­ le respect du tempo et des durÃ©es dÃ©finies</li>
          </ul>
        </li>
      </ol>
    </section>

  </main>

  <footer>ulid-worker â€¢ CodÃ© avec ğŸ’š par RaphaÃ«l et ğŸ¤– â€¢ Licence MIT</footer>

  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.5/build/cjs/vexflow.js"></script>

  <script type="module">

    /* ===== Constantes & tables ===== */
    const $ = id => document.getElementById(id);


    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Ã‰TAT GLOBAL & CONFIG     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
    
    // Ã‰tats principaux (ULID courant, sÃ©quence courante, timers, etc.)
    let ULID = "";
    let seq = [];
    let timers = [];
    
    // Indique si une lecture est en cours
    let isPlaying = false;
    
    // Octave courante Â« gelÃ©e Â» pour la lecture en cours (null = pas de lecture)
    let playbackBaseOctave = null;
    
    // MÃ©mo pour lâ€™instrument courant et la promesse de chargement
    let currentSampler = null;
    let currentSamplerReady = Promise.resolve();
    
    // MÃ©mo pour surbrillance
    let lastHighlight = null;
    let lastRow = null;
    
    // Flags liÃ©s Ã  lâ€™UI (pending instrument, update visuel diffÃ©rÃ©)
    let pendingInstrument = null;
    let pendingVisualUpdate = false;
    
    // Flag pause lecture
    let isPaused = false;
    
    // Constantes de configuration
    const crock = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    
    // Table de cache pour les gammes 16 notes
    const _tbl16Cache = Object.create(null);
    
    // Dictionnaire des dÃ©finitions dâ€™accords
    const chordDefs = {
      none   : [0],
      power  : [0,4],        // 1â€‘5
      triad  : [0,2,4],      // 1â€‘3â€‘5
      seventh: [0,2,4,6]     // 1â€‘3â€‘5â€‘7
    };
    
    // Liste et configuration des instruments
    const instrumentFiles = {
      marimba: {
        base: "./samples/Samples_Marimba/",
        files: {
          "A2": "A2.80966957.mp3",
          "A3": "A3.cc7d0a4b.mp3",
          "A4": "A4.f93d2aa3.mp3",
          "A5": "A5.c4c561f2.mp3",
          "A6": "A6.7b7ed4b2.mp3",
          "C2": "C2.2c273809.mp3",
          "C3": "C3.bf6e7680.mp3",
          "C4": "C4.b5cfeca7.mp3",
          "C5": "C5.53bc9580.mp3",
          "C6": "C6.0da1964c.mp3",
        }
      },
      piano: {
        base: "./samples/Samples_Piano/",
        files: {

          "A2": "A2v8.mp3",
          "A3": "A3v8.mp3",
          "A4": "A4v8.mp3",
          "A5": "A5v8.mp3",
          "A6": "A6v8.mp3",
          "A7": "A7v8.mp3",
          "C1": "C1v8.mp3",
          "C2": "C2v8.mp3",
          "C3": "C3v8.mp3",
          "C4": "C4v8.mp3",
          "C5": "C5v8.mp3",
          "C6": "C6v8.mp3",
          "C7": "C7v8.mp3",
          "C8": "C8v8.mp3",
        }
      },
      strings: {
        base: "./samples/Samples_Strings/",
        files: {
          "A2": "A2.32eab706.mp3",
          "A3": "A3.ead476da.mp3",
          "A4": "A4.79029edf.mp3",
          "A5": "A5.bda0be10.mp3",
          "A6": "A6.e1417bdc.mp3",
          "C2": "C2.4df4b0a2.mp3",
          "C3": "C3.9a2d50aa.mp3",
          "C4": "C4.31bc4670.mp3",
          "C5": "C5.4f7ad86c.mp3",
          "C6": "C6.655fa406.mp3",
        }
      },
      synth: {
        base: "./samples/Samples_Synth/",
        files: {
          "A2": "A2.d39e6a1e.mp3",
          "A3": "A3.2583ee7f.mp3",
          "A4": "A4.02c12517.mp3",
          "A5": "A5.20b412cf.mp3",
          "A6": "A6.46657279.mp3",
          "C2": "C2.9e3b6556.mp3",
          "C3": "C3.54c3718a.mp3",
          "C4": "C4.3eba7397.mp3",
          "C5": "C5.731ab831.mp3",
          "C6": "C6.5b196566.mp3",
        }
      },
      woodwind: {
        base: "./samples/Samples_Woodwind/",
        files: {
          "A2": "A2.c94f91ab.mp3",
          "A3": "A3.44853c04.mp3",
          "A4": "A4.4849e599.mp3",
          "A5": "A5.1b9b02ba.mp3",
          "A6": "A6.8f960bfa.mp3",
          "C2": "C2.e247094b.mp3",
          "C3": "C3.254276f0.mp3",
          "C4": "C4.858d5d62.mp3",
          "C5": "C5.c7a85606.mp3",
          "C6": "C6.a1140119.mp3",
        }
      },
    };
    
    const instrumentBehavior = {
      piano:    "full",
      marimba:  "full",
      strings:  "full",
      synth:    "cut",
      woodwind: "cut"
    };


    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  HELPERS PURS             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
    
    // Conversion ULID en 128 bits binaires (string)
    function toBits(ulid) {
      return ulid
        .split("")
        .map(c => crock.indexOf(c).toString(2).padStart(5, "0"))
        .join("")
        .slice(0, 128);
    }
    
    // Coupe en 32 nibbles (tableau de 32Ã— "0000" Ã  "1111")
    function chunk4(bits) {
      return Array.from({ length: 32 }, (_, i) => bits.slice(i*4, i*4 + 4));
    }
    
    // GÃ©nÃ©ration dâ€™un ULID conforme (timestamp ou alÃ©a)
    function makeUlid(ts) {
      const crock = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
      let ts48;
      if (ts === 'random') {
        ts48 = BigInt(0);
        for (let i = 0; i < 6; i++) {
          ts48 = (ts48 << 8n) | BigInt(Math.floor(Math.random() * 256));
        }
      } else {
        let tsVal;
        if (typeof ts === "number" && isFinite(ts)) {
          tsVal = Math.floor(ts);
        } else if (typeof ts === "string" && /^\d+$/.test(ts)) {
          tsVal = Math.floor(Number(ts));
        } else if (ts === undefined || ts === null) {
          tsVal = Date.now();
        } else {
          tsVal = Date.now();
        }
        ts48 = BigInt(tsVal) & 0xFFFFFFFFFFFFn;
      }
      let tsBase32 = "";
      let v = ts48;
      for (let i = 0; i < 10; i++) {
        tsBase32 = crock[Number(v % 32n)] + tsBase32;
        v = v / 32n;
      }
      let rand = BigInt(0);
      for (let i = 0; i < 10; i++) {
        rand = (rand << 8n) | BigInt(Math.floor(Math.random() * 256));
      }
      let randBase32 = "";
      v = rand;
      for (let i = 0; i < 16; i++) {
        randBase32 = crock[Number(v % 32n)] + randBase32;
        v = v / 32n;
      }
      return tsBase32 + randBase32;
    }
    function makeUlidNow()    { return makeUlid(Date.now()); }
    function makeUlidRandom() { return makeUlid(); }
    
    // Table de 16 notes (gamme de base, mÃ©moÃ¯sÃ©e par octave)
    function getTable16(baseOctave = 4){
      if (_tbl16Cache[baseOctave]) return _tbl16Cache[baseOctave];
      const base = ["C","D","E","F","G","A","B"];
      const out  = [];
      let   oct  = baseOctave;
      for(let i=0;i<16;i++){
        out.push(base[i%7] + oct);
        if(base[i%7]==="B") oct++;
      }
      return (_tbl16Cache[baseOctave] = out);
    }
    
    // AccordsÂ : retourne la liste des notes de lâ€™accord, modulo 16
    function chordify(note, type, table){
      const idx = table.indexOf(note);
      if (idx === -1) return [note];
      return chordDefs[type].map(d => table[(idx + d) % table.length]);
    }
    
    // XOR adaptatifÂ : logique de rythme rapide/lent
    function xorAdaptiveFrom(val, rev, i) {
      const x = val ^ rev;
      const b0 = (x >> 0) & 1;
      const b1 = (x >> 1) & 1;
      const b2 = (x >> 2) & 1;
      const b3 = (x >> 3) & 1;
      return (i % 2 === 0) ? (b1 ^ b3) : (b0 ^ b2);
    }
    
    // Statistiques rythmiques (nombre de rapides/lentes/battements)
    function calcRhythmStats(seq) {
      const fast  = seq.filter(o => o.fast).length;
      const slow  = seq.length - fast;
      const beats = seq.reduce((s, o) => s + (o.fast ? 1 : 2), 0);
      return { fast, slow, beats };
    }
    
    // ArpÃ©giateur (ordre de jeu des notes selon motif)
    function arp(arr, pattern) {
      switch (pattern) {
        case "up":      return arr;
        case "down":    return [...arr].reverse();
        case "updown":  return [...arr, ...[...arr].reverse()];
        case "random":  return [...arr].sort(() => Math.random() - 0.5);
        default:        return arr;
      }
    }
    
    // Format date humanisÃ© (optionnel ici)
    function formatFullDate(isoString) {
      const d = new Date(isoString);
      const days = ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"];
      const months = ["janvier", "fÃ©vrier", "mars", "avril", "mai", "juin",
                      "juillet", "aoÃ»t", "septembre", "octobre", "novembre", "dÃ©cembre"];
      const dayName = days[d.getUTCDay()];
      const day     = d.getUTCDate().toString().padStart(2, "0");
      const month   = months[d.getUTCMonth()];
      const year    = d.getUTCFullYear();
      const hour    = d.getUTCHours().toString().padStart(2, "0");
      const minute  = d.getUTCMinutes().toString().padStart(2, "0");
      const second  = d.getUTCSeconds().toString().padStart(2, "0");
      const ms      = d.getUTCMilliseconds().toString().padStart(3, "0");
      return `${dayName} ${day} ${month} ${year} Ã  ${hour}:${minute}:${second}.${ms} UTC`;
    }

    // Anti-rebond pour les inputs
    const debounce = (fn, d = 300) => {
      let t; return (...a)=>{ clearTimeout(t); t=setTimeout(fn, d, ...a); };
    };
    
    // Conversion ULID â†’ sÃ©quence complÃ¨te (tableau dâ€™objets {val, fast})
    function ulidToSequence(v) {
      const bits    = toBits(v);
      const nibbles = chunk4(bits);
      const vals    = nibbles.map(b => parseInt(b, 2));
      const revs    = [...vals].reverse();
      return vals.map((val, i) => ({
        val,
        fast: xorAdaptiveFrom(vals[i], revs[i], 31 - i) === 1
      }));
    }
    
    // Renvoie lâ€™octave courante (figÃ©e pendant lecture, sinon du select)
    const getBaseOctave = () =>
          (playbackBaseOctave !== null)
            ? playbackBaseOctave
            : parseInt($("octaveShift").value, 10);


    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  HELPERS MÃ‰TIER (audio, sample)
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
    
    // Chargement asynchrone de lâ€™instrument/sampler
    async function loadSampler(type) {
      const prevSampler = currentSampler;
      const def = instrumentFiles[type];
      const baseOct = parseInt($("octaveShift").value, 10);
      const table16 = getTable16(baseOct);
      const neededOctaves = [...new Set(
        table16.map(n => parseInt(n.match(/\d+$/)[0], 10))
      )];
      const files = {};
      Object.entries(def.files).forEach(([note, file]) => {
        const oct = parseInt(note.match(/\d+$/)[0], 10);
        if (neededOctaves.includes(oct)) {
          files[note] = file;
        }
      });
      let resolveReady;
      const samplerReady = new Promise(r => (resolveReady = r));
      const sampler = new Tone.Sampler({
        urls:    files,
        baseUrl: def.base,
        onload: () => {
          if (prevSampler) prevSampler.dispose();
          resolveReady();
        }
      });
      const volume  = new Tone.Volume(-8);
      const reverb  = new Tone.Reverb({ decay: 2, wet: 0.3 });
      const limiter = new Tone.Limiter(-1);
      sampler.chain(volume, reverb, limiter, Tone.Destination);
      currentSampler      = sampler;
      currentSamplerReady = samplerReady;
      return currentSamplerReady;
    }


    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  RENDERING & UI             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
    
    // Affiche la grille binaire (SVG) pour chaque niveau (nibbles, inversÃ©s, etc.)
    function renderBitGrid(intArray, svgId, adaptiveFn = null) {
      const svg = $(svgId);
      svg.innerHTML = "";

      /* â€”â€”â€” Dimensions dynamiques â€”â€”â€” */
      const n       = 32;
      const headerH = 12;        /* bandeau numÃ©ros */
      const lblW    = 22;        /* marge gauche b0â€‘b3 */
      const gap     = 4;         /* px entre groupes de 8 */

      /* largeur rÃ©elle du conteneur (100â€¯% du parent) */
      const cssW   = svg.clientWidth || 320;
      const pillW  = Math.floor((cssW - lblW - 3 * gap) / n);
      const pillH  = 16;         /* hauteur fixe lisible */

      const totalW = lblW + n * pillW + 3 * gap;  /* == cssW */
      const totalH = headerH + (adaptiveFn ? pillH : 4 * pillH);

      svg.setAttribute("viewBox", `0 0 ${totalW} ${totalH}`);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      /* â€”â€”â€”Â Contenu â€”â€”â€” */
      intArray.forEach((val, i) => {
        const bits = val.toString(2).padStart(4, "0").split("").map(Number);
        const g    = document.createElementNS("http://www.w3.org/2000/svg", "g");

        const x = lblW + i * pillW + Math.floor(i / 8) * gap;
        g.setAttribute("transform", `translate(${x},${headerH})`);

        if (adaptiveFn) {
          const v = adaptiveFn(val, i);
          const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          r.setAttribute("x", 0);
          r.setAttribute("y", 0);
          r.setAttribute("width", pillW - 1);
          r.setAttribute("height", pillH);
          r.setAttribute("rx", "1");
          r.setAttribute("ry", "1");
          r.setAttribute("fill", v ? "var(--bit-xor-adapt)" : "var(--bit-off)");
          g.appendChild(r);
        } else {
          bits.forEach((b, j) => {
            const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            r.setAttribute("x", 0);
            r.setAttribute("y", j * pillH + 0.5);
            r.setAttribute("width", pillW - 1);
            r.setAttribute("height", pillH - 1);
            r.setAttribute("rx", "1");
            r.setAttribute("ry", "1");
            r.setAttribute("fill", b ? "var(--bit-on)" : "var(--bit-off)");

            const needBorder =
              (i % 2 === 0 && (j === 1 || j === 3)) ||
              (i % 2 === 1 && (j === 0 || j === 2));
            if (svgId === "xor-bits" && needBorder) {
              r.setAttribute("stroke", "var(--bit-xor-adapt)");
              r.setAttribute("stroke-width", "1");
            }

            g.appendChild(r);
          });

        }
        svg.appendChild(g);
      });

      /* â€”â€”â€” NumÃ©rotation des colonnes 32 âœ 1 â€”â€”â€” */
      for (let i = 0; i < n; i++) {
        const x = lblW + i * pillW + Math.floor(i / 8) * gap + pillW / 2;
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", x);
        t.setAttribute("y", headerH - 2);
        t.setAttribute("text-anchor", "middle");
        t.setAttribute("font-size", "10");
        t.setAttribute("fill", "var(--text)");
        t.textContent = n - i;            /* 32 Ã  gauche â†’ 1 Ã  droite */
        svg.appendChild(t);
      }

      /* â€”â€”â€”Â Labels de ligne (b0â€¥b3) â€”â€”â€” */
      if (!adaptiveFn) {
        ["b0", "b1", "b2", "b3"].forEach((lbl, j) => {
          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", lblW - 2);
          t.setAttribute("y", headerH + j * pillH + pillH / 2 + 4);
          t.setAttribute("text-anchor", "end");
          t.setAttribute("font-size", "10");
          t.setAttribute("fill", "var(--text)");
          t.textContent = lbl;
          svg.appendChild(t);
        });
      }
    }
    
    // Affiche une portÃ©e VexFlow, avec surbrillance Ã©ventuelle
    function renderStaff(containerId, blockSeq, table16,
                        highlightIdx = -1, forcedOctave = null){
      try {
        const VF = window.Vex?.Flow;
        if (!VF) return;
        const container = $(containerId);
        if (!container) return;
        container.replaceChildren();
      
        const parentW = container.clientWidth;
        const vf = new VF.Factory({ renderer: { elementId: containerId, width: parentW, height: 140 } });
        const score = vf.EasyScore();
        const sys   = vf.System();
      
        const baseOctave = forcedOctave !== null ? forcedOctave : getBaseOctave();
        const clef = baseOctave <= 2 ? "bass" : baseOctave === 3 ? "alto" : "treble";
      
        const chordT   = $("chordsSel").value;
        const arpStyle = $("arp").value;
        const parts = [];
        blockSeq.forEach(o => {
          const root       = table16[o.val];
          const dur        = o.fast ? "16" : "8";
          const chordNotes = chordify(root, chordT, table16);
          if (chordT !== "none" && arpStyle === "none") {
            parts.push(`(${chordNotes.map(n => n.toLowerCase()).join(" ")})/${dur}`);
          } else if (arpStyle !== "none" && chordNotes.length > 1) {
            const ordered =
              arpStyle === "down"   ? [...chordNotes].reverse() :
              arpStyle === "random" ? arp([...chordNotes], "random") :
              chordNotes;
            ordered.forEach(n => parts.push(`${n.toLowerCase()}/${dur}`));
          } else {
            parts.push(`${root.toLowerCase()}/${dur}`);
          }
        });
        const sliceString = parts.join(", ");
        let beats16 = 0;
        parts.forEach(tok => { beats16 += tok.endsWith("/16") ? 1 : 2; });
        const notesArr = score.notes(sliceString);
        const beams = VF.Beam.generateBeams(notesArr);
        beams.forEach(beam => vf.Beam({ notes: beam.getNotes() }));
        const voice = score.voice(notesArr, {
          time: { num_beats: beats16, beat_value: 16 },
          strict: false
        });
        voice.setMode(VF.Voice.Mode.SOFT);
        sys.addStave({
          voices: [voice],
          time_signature: `${beats16}/16`
        }).addClef(clef);
        vf.draw();
        const gNotes = container.querySelectorAll('.vf-stavenote');
        gNotes.forEach(g => g.classList.remove("note-play"));
        if (highlightIdx >= 0 && gNotes[highlightIdx]) gNotes[highlightIdx].classList.add("note-play");
        return parts.length;
      } catch (err) {
        // log mais ne bloque pas tout le rendu
        if (window?.console) console.error("Erreur renderStaff:", err);
        return 0;
      }
    }
    
    // Dessine les 4 portÃ©es et dÃ©cide de lâ€™empilement
    function draw(seq){
      const baseOct = (playbackBaseOctave ?? getBaseOctave());
      const table16 = getTable16(baseOct);

      /* 1ï¸âƒ£  DÃ©cide dâ€™abord si lâ€™on empile ou non */
      let maxNotes = 0;
      for (let b = 0; b < 4; b++) {
        const cnt = countBlockNotes(seq.slice(b * 8, b * 8 + 8), table16);
        if (cnt > maxNotes) maxNotes = cnt;
      }
      const grids = $("note-grids");
      (maxNotes > 8) ? grids.classList.add("stacked")
                     : grids.classList.remove("stacked");

      /* 2ï¸âƒ£  Puis on (re)dessine chacune des portÃ©es */
      for (let b = 0; b < 4; b++) {
        const blockSeq = seq.slice(b * 8, b * 8 + 8);
        const fo = (playbackBaseOctave !== null ? playbackBaseOctave : null);
        renderStaff("staff" + b, blockSeq, table16, -1, fo);
      }
    }
    
    // Surbrillance temps rÃ©el tableau + partition
    function highlightNote(i, subOffset = 0){

      const arpStyle = $("arp").value;
      const chordT = $("chordsSel").value;
      const baseOctave = getBaseOctave();
      const table16 = getTable16(baseOctave);
      const isUpdown = arpStyle === "updown";
      const realIdx = isUpdown && i >= seq.length ? 2 * seq.length - i - 1 : i;

      /* O(1) : on retire lâ€™ancienne ligne au lieu dâ€™un querySelectorAll */
      if (lastRow) lastRow.classList.remove('playing-row');

      const cell = document.getElementById("play-cell" + realIdx);
      if (cell) {
        const row = cell.closest("tr");
        row.classList.add("playing-row");
        lastRow = row;
        cell.classList.add("playing");

        const notes = JSON.parse(row.dataset.notes);

        const tid = setTimeout(() => cell.classList.remove("playing"), 200);
        timers.push(tid);
      }

      /* PortÃ©e ----------------------------------------------------- */
      const bloc = Math.floor(realIdx / 8);   /* realIdx = 0-31 mÃªme en descente */
      if (bloc > 3) return;                   /* on nâ€™a que 4 portÃ©es */
      /* O(1) : retire lâ€™ancienne surbrillance */
      if (lastHighlight) lastHighlight.classList.remove('note-play');

      /* Redessine la portÃ©e miniature avec la note active */
      drawMini(bloc, realIdx % 8, seq, subOffset, table16)

      /* MÃ©morise la nouvelle tÃªte mise en Ã©vidence */
      const container = $('staff' + bloc);
      lastHighlight   = container.querySelector('.note-play');
    }
    
    // Met Ã  jour la direction des flÃ¨ches de notes dans les tables (up/down)
    function updateArrowDirection(isDescending) {
      document.querySelectorAll("tr[data-i]").forEach(tr => {
        const i = tr.dataset.i;
        const notes = JSON.parse(tr.dataset.notes);
        const td = document.getElementById("notes-" + i);
        if (td && notes.length > 1) {
          td.textContent = (isDescending ? [...notes].reverse() : notes).join(isDescending ? " â† " : " â†’ ");
        }
      });
    }
    
    // Calcule le nombre de tÃªtes de notes dans un bloc (pour layout grille/stack)
    function countBlockNotes(blockSeq, table16){
      const chordT   = $("chordsSel").value;
      const arpStyle = $("arp").value;
      let cnt = 0;
      blockSeq.forEach(o => {
        const root       = table16[o.val];
        const chordNotes = chordify(root, chordT, table16);
        if (chordT !== "none" && arpStyle === "none") {
          cnt += 1;                       /* accord simultanÃ© = 1 tÃªte */
        } else if (arpStyle !== "none" && chordNotes.length > 1) {
          cnt += chordNotes.length;       /* arpÃ¨ge = n tÃªtes */
        } else {
          cnt += 1;
        }
      });
      return cnt;
    }
    
    // Affiche un mini rendu de portÃ©e sur staffX (pour highlight)
    function drawMini(block, seqIdxInBlock, seq, subOffset = 0, table16){
      const blockSeq = seq.slice(block * 8, block * 8 + 8);
      const chordT   = $("chordsSel").value;
      const arpStyle = $("arp").value;

      /* Calcule le dÃ©calage (en # de tÃªtes) avant lâ€™index Ã  mettre en surbrillance */
      let noteIdx = 0;
      for (let k = 0; k < seqIdxInBlock; k++) {
        const root       = table16[blockSeq[k].val];
        const chordNotes = chordify(root, chordT, table16);
        if (chordT !== "none" && arpStyle === "none") {
          noteIdx += 1;                          /* accord simultanÃ© = 1 tÃªte */
        } else if (arpStyle !== "none" && chordNotes.length > 1) {
          noteIdx += chordNotes.length;          /* arpÃ¨ge = n tÃªtes */
        } else {
          noteIdx += 1;                          /* note simple */
        }
      }

      noteIdx += subOffset;               /* 2áµ‰, 3áµ‰ note de lâ€™arpÃ¨ge, â€¦ */
      const fo = (playbackBaseOctave !== null ? playbackBaseOctave : null);
      renderStaff("staff" + block, blockSeq, table16, noteIdx, fo);
    }
    
    // Rendu complet des tableaux + staff
    function renderTablesAndStaff(seq, table16){

      const chordT = $("chordsSel").value;
      const isUpdown = $("arp").value === "updown";
      const totalBlocks = 4;

      // 1. Vider les tableaux
      for (let t = 0; t < totalBlocks; t++) {
        const tid = "tbl" + t;
        if ($(tid)) $(tid).innerHTML = "";
      }
      $("staff-wrapper").innerHTML = "";

      // 2. Remplir ligne par ligne
      seq.forEach((o, i) => {
        const b = o.val.toString(2).padStart(4, "0");
        const tbl  = "tbl" + Math.floor(i / 8);
        const dur  = o.fast ? "1/16" : "1/8";
        const rowIdx = i + 1;
  
        const root = table16[o.val];
        const chordNotes = chordify(root, chordT, table16);
  
        const arpStyle = $("arp").value;
        let noteDisplay = "";
  
        if (chordNotes.length === 1 || arpStyle === "none") {
          noteDisplay = chordNotes[0];
        } else if (arpStyle === "updown") {
          // on n'affiche que la phase montante
          noteDisplay = chordNotes.join(" â†’ ");
        } else {
          const ordered = arp(chordNotes, arpStyle);
          noteDisplay = ordered.join(" â†’ ");
        }
  
        const row  = `
          <tr data-i="${i}" data-notes='${JSON.stringify(chordNotes)}'>
            <td>${rowIdx}</td>
            <td>${dur}</td>
            <td id="notes-${i}">${noteDisplay}</td>
            <td class="playing-col" id="play-cell${i}"></td>
          </tr>`;
        $(tbl).insertAdjacentHTML("beforeend", row);
      });

      /* Un seul rendu â€“ Ã©vite les 4 portÃ©es supplÃ©mentaires */
      draw(seq);
    }
    
    // Ligne de nibbles binaire, valeur, note (pour validateUlid)
    function renderNibbleLine(target, contentArr) {
      const frag = document.createDocumentFragment();
      contentArr.forEach(txt => {
        const span = document.createElement("span");
        span.textContent = txt;
        frag.appendChild(span);
      });
      target.innerHTML = "";
      target.appendChild(frag);
    }
    
    // RafraÃ®chit tout lâ€™affichage (octave/accord/arpÃ¨ge modifiÃ©s)
    function refreshDisplayAfterOctaveChange() {
      if (isPlaying) return;
      if (ULID && seq.length > 0) {
        const baseOctave = playbackBaseOctave ?? getBaseOctave();
        const table16    = getTable16(baseOctave);
        $("note-sequence").textContent =
          "ğŸµ SÃ©quence :\n" + seq.map(o => table16[o.val]).join(", ");
        renderTablesAndStaff(seq, table16);
      }
    }
    
    // Synchronise BPM <-> DurÃ©e dâ€™une noire
    function syncTempoFields(source) {
      const bpmInput = $("tempoBpm");
      const durInput = $("tempoDur");
      if (source === "bpm") {
        const bpm = parseFloat(bpmInput.value);
        if (bpm > 0) durInput.value = (60 / bpm).toFixed(2);
      } else {
        const dur = parseFloat(durInput.value);
        if (dur > 0) bpmInput.value = Math.round(60 / dur);
      }
    }

    // GÃ©nÃ¨re un nouvel ULID, le place dans le champ, valide l'entrÃ©e
    function newUid(){
      const id = makeUlidNow();
      $("ulid-input").value = id;
      validateUlid(id);
    }
    
    // RÃ©initialisation complÃ¨te de la lecture et de lâ€™affichage
    function clearAll(time) {
      if (typeof time === "number") Tone.Transport.stop(time);
      else Tone.Transport.stop();
      Tone.Transport.cancel();
      timers.forEach(clearTimeout);
      timers.length = 0;
      if (lastHighlight) lastHighlight.classList.remove("note-play");
      lastHighlight = null;
      document.querySelectorAll("tr.playing-row")
              .forEach(r => r.classList.remove("playing-row"));
      $("pause").textContent = "â¸ Pause";
      $("pause").disabled    = true;
    }
    
    // Validation dâ€™un ULID (appel au worker + maj UI)
    async function validateUlid(v) {
      v = v.trim().toUpperCase();
      $("ulid-input").value = v;
      const baseOctave    = getBaseOctave();
      const table16       = getTable16(baseOctave);
      const binLine       = $("nibbles-binary");
      const valLine       = $("nibbles-values");
      const noteLine      = $("nibbles-notes");
      const statusEl = $("ulid-status");
      let   res, data;
      try{
        res  = await fetch('/ulid?check=' + encodeURIComponent(v));
        data = await res.json();
      }catch(err){
        statusEl.textContent = "â›” Erreur rÃ©seau ("+err.message+")";
        statusEl.style.color = "var(--error,#f00)";
        $("ulid-ts-preview").textContent = "ğŸ“† Date : â€”";
        return;
      }
      if (res.ok && data.conform) {
        $("play").disabled = false;
        statusEl.textContent = "âœ… ULID conforme";
        statusEl.style.color = "var(--success,#00ff00)";
        $("ulid-ts-preview").textContent = "ğŸ“† Date : " + formatFullDate(data.ts);
        clearAll();
        $("note-grids").style.display = "grid";
        seq = ulidToSequence(v);
        const vals = seq.map(o => o.val);
        const revs = [...vals].reverse();
        const xors = vals.map((v, i) => v ^ revs[i]);
        ["nibbles-bits", "reversed-bits", "xor-bits", "xor-adaptive"]
          .forEach(id => $(id).innerHTML = "");
        renderBitGrid(vals,     "nibbles-bits");
        renderBitGrid(revs,     "reversed-bits");
        renderBitGrid(xors,     "xor-bits");
        renderBitGrid(
          [...xors].reverse(),
          "xor-adaptive",
          (_, i) => xorAdaptiveFrom(vals[31 - i], revs[31 - i], 31 - i)
        );
        const fastCount = seq.filter(o => o.fast).length;
        const slowCount = seq.length - fastCount;
        const beatCount = seq.reduce((s, o) => s + (o.fast ? 1 : 2), 0);
        const tempo = parseFloat($("tempoDur").value);
        const duration = (beatCount * tempo).toFixed(2);
        $("summary").textContent =
          `â±ï¸ DurÃ©e estimÃ©e : ${duration} sec\n` +
          `ğŸ¼ Battements : ${beatCount} (sur ${seq.length * 2} max)\n` +
          `âš–ï¸ Rythme : ${fastCount} rapides / ${slowCount} lentes`;
        ULID = v;
        renderNibbleLine(binLine, vals.map(val => val.toString(2).padStart(4, "0")));
        renderNibbleLine(valLine, vals.map(val => val));
        renderNibbleLine(noteLine, vals.map(val => table16[val]));
        $("ulid-decode").classList.remove("hidden");
        $("note-sequence").textContent = "ğŸµ SÃ©quence :\n" + seq.map(o => table16[o.val]).join(", ");
        for (let b = 0; b < 4; b++) {
          $("tbl" + b).innerHTML   = "";
          $("staff" + b).innerHTML = "";
        }
        renderTablesAndStaff(seq, table16);
      } else {
        $("play").disabled = true;
        statusEl.textContent = "âŒ " + (data.error || "");
        statusEl.style.color = "var(--error,#f00)";
        $("ulid-ts-preview").textContent = "ğŸ“† Date : â€”";
        $("note-sequence").textContent = "ğŸµ SÃ©quence :\n â€”";
        ["nibbles-bits", "reversed-bits", "xor-bits", "xor-adaptive"]
          .forEach(id => $(id).innerHTML = "");
        $("summary").textContent =
          `â±ï¸ DurÃ©e estimÃ©e : â€” \n` +
          `ğŸ¼ Battements : â€” \n` +
          `âš–ï¸ Rythme : â€”`;
        $("note-grids").style.display = "none";
      }
    }


    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  UIÂ : LISTENERS & WORKFLOW  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/
    
    // RafraÃ®chit la sÃ©quence Ã  chaque modif de lâ€™accord, arpÃ¨ge ou octave (input mutualisÃ©)
    ['chordsSel','arp','octaveShift']
      .forEach(id =>
        $(id).addEventListener('input', refreshDisplayAfterOctaveChange)
      );
    
    // Validation ULID avec anti-rebond
    $("ulid-input").addEventListener(
      "input",
      debounce(() => {
        validateUlid($("ulid-input").value);
      }, 300)
    );
    
    // Synchronisation BPM / DurÃ©e noire
    $("tempoBpm").addEventListener("input", () => syncTempoFields("bpm"));
    $("tempoDur").addEventListener("input", () => syncTempoFields("dur"));
    
    // Boutons ULID random/maintenant
    $("ulid-random").onclick = () => {
      const id = makeUlidRandom();
      $("ulid-input").value = id;
      validateUlid(id);
    };
    $("ulid-now").onclick = () => {
      const id = makeUlidNow();
      $("ulid-input").value = id;
      validateUlid(id);
    };
    
    // Gestion bouton Stop
    $("stop").onclick = () => {
      clearAll();
      isPlaying = false;
      playbackBaseOctave = null;
      ["instrumentSel","octaveShift","chordsSel","arp",
       "tempoBpm","tempoDur"].forEach(id => $(id).disabled = false);
      isPaused = false;
      $("pause").textContent = "â¸ Pause";
      $("pause").disabled = true;
    };
    
    // Lecture : Play
    $("play").onclick = async () => {
      if (!seq || seq.length === 0) return;
      isPlaying = true;
      ["instrumentSel","octaveShift","chordsSel","arp",
       "tempoBpm","tempoDur"].forEach(id => $(id).disabled = true);
      playbackBaseOctave = parseInt($("octaveShift").value, 10);
      const baseOctave   = playbackBaseOctave;
      const table16      = getTable16(baseOctave);
      const transposed = table16;
      await Tone.start();
      if (isPlaying) {
        await new Promise(resolve => {
          Tone.Transport.once("stop", resolve);
          clearAll();
        });
      } else {
        clearAll();
      }
      if (pendingInstrument) {
        await loadSampler(pendingInstrument);
        pendingInstrument = null;
      }
      await currentSamplerReady;
      isPaused = false;
      $("pause").textContent = "â¸ Pause";
      $("pause").disabled = false;
      const chordT = $("chordsSel").value;
      const pat = $("arp").value;
      const seqArr = arp(seq, pat);
      Tone.Transport.cancel();
      updateArrowDirection(false);
      let pos = 0;
      const tempo = parseFloat($("tempoDur").value);
      const isUpdown = pat === "updown";
      const len = seqArr.length;
      const instrument = $("instrumentSel").value;
      const playMode = instrumentBehavior[instrument];
      seqArr.forEach((o, i) => {
        const dur = tempo * (o.fast ? 0.5 : 1);
        Tone.Transport.schedule(t => {
          if (isUpdown && i === Math.floor(len / 2)) {
            updateArrowDirection(true);
          }
        }, pos);
        const note        = transposed[o.val];
        const chordNotes  = chordify(note, chordT, transposed);
        const arpeggiate  = (pat !== "none" && chordT !== "none" && chordNotes.length > 1);
        const isDescending = isUpdown && i >= len / 2;
        const chordSeq = (arpeggiate && isDescending) ? [...chordNotes].reverse() : chordNotes;
        chordSeq.forEach((n, j) => {
          const offset   = arpeggiate ? j * (dur / chordSeq.length) : 0;
          const when     = pos + offset;
          const noteDur  = (playMode === "full") ? undefined : dur / chordSeq.length;
          Tone.Transport.schedule(t => {
            if (playMode === "full") {
              currentSampler.triggerAttack(n, t);
            } else {
              currentSampler.triggerAttackRelease(n, noteDur, t);
            }
          }, when);
          const jAdj = arpeggiate
                       ? (isDescending ? chordSeq.length - 1 - j : j)
                       : 0;
          Tone.Transport.schedule(() => {
            highlightNote(i, jAdj);
          }, when);
        });
        pos += dur;
      });
      Tone.Transport.scheduleOnce((time) => {
        Tone.Transport.stop(time);
        updateArrowDirection(false);
        clearAll(time);
        isPlaying = false;
        playbackBaseOctave = null;
        ["instrumentSel","octaveShift","chordsSel","arp",
         "tempoBpm","tempoDur"].forEach(id => $(id).disabled = false);
        isPaused = false;
        $("pause").textContent = "â¸ Pause";
        $("pause").disabled = true;
      }, pos + tempo);
      Tone.Transport.start("+0");
    };
    
    // Pause/Reprendre
    $("pause").onclick = () => {
      if (Tone.Transport.state === "started") {
        Tone.Transport.pause();
        isPaused = true;
        $("pause").textContent = "â–¶ Reprendre";
      } else if (Tone.Transport.state === "paused" && isPaused) {
        Tone.Transport.start();
        isPaused = false;
        $("pause").textContent = "â¸ Pause";
      }
    };
    
    
    /*â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  UIÂ : LISTENERS & WORKFLOW  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€*/

    (async () => {
      await loadSampler("piano");
      newUid();
      $("pause").disabled = true;
      if (!seq || seq.length === 0) $("play").disabled = true;
    })();

  </script>

  <!-- enfin ton script principal -->
  <script type="module" src="./site.js"></script> 

</body>
</html>
