<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>🎶 ULID Music</title>

  <!-- Thème avant chargement du CSS -->
  <script>
    const currentTheme = window.matchMedia("(prefers-color-scheme: dark)").matches;
    document.documentElement.setAttribute("data-theme", currentTheme ? "dark" : "light");
  </script>

  <!-- ton CSS -->
  <link rel="stylesheet" href="/style.css"/>

  <style>

    /* conteneur générique pour faire 2 colonnes puis 1 colonne */
    .flex-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
    }
    /* chaque “groupe” fait 1/2 du conteneur, au minimum 250px */
    .group {
      flex: 1 1 45%;
      min-width: 250px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    /* Media query : < 600px on passe à 1 colonne */
    @media (max-width: 600px) {
      .group {
        flex: 1 1 100%;
      }
    }

    /* ── Taille fixe pour l’ULID (26 caractères Base32) ── */
    #ulid-input {
      flex: none;              /* pas d’expansion/shrink */
      width: 28ch;             /* 26 “0” de large, soit pile la longueur d’un ULID */
      box-sizing: border-box;  /* inclut padding/border dans ces 26ch */
    }
    
    /* ── Prévisualisation date : ne pas réduire, afficher tout le texte ── */
    #ulid-ts-preview {
      flex: none;              /* taille auto selon contenu */
      min-width: max-content;  /* largeur mini = largeur du texte */
    }

    /* Partition : applicables à #staff et staff0..staff3 */
    [id^="staff"] {
      background: var(--bg);
    }

    /* Sélecteur simplifié : 1-seul « match » par élément */
    [id^="staff"] svg {
      stroke: var(--text);
      fill:   var(--text);
      max-width: 100%;
      display: block;
    }
    [id^="staff"] .note-play * {
      stroke: var(--heading) !important;
      fill:   var(--heading) !important;
    }

    /* ── Partition : note en cours ─────────────────────────── */
    /* VexFlow baptise les groupes <g> .vf-stavenote → on les colore */
    .note-play path,
    .note-play ellipse {
      fill:   var(--heading) !important;   /* tête de note */
      stroke: var(--heading) !important;   /* hampe / ligature */
    }

    /* ── Tableau : pastille « Playing » ────────────────────── */
    .playing-col{ text-align:center; vertical-align:middle; }
    .playing-col.playing::before{   /* pastille visible uniquement */
      content: "";
      display: inline-block;
      width:  .75em;
      height: .75em;
      border-radius: 50%;
      background: var(--heading);
      vertical-align:middle;
    }

    /* Mini‐tables : 4×8 notes */
    .mini table {
      width: 100%;
      border-collapse: collapse;
      font-size:    .85rem;
      margin-top:   .5rem;
    }


    .mini th,
    .mini td {
      color: var(--text);
      padding: 0.2em 0.3em;
      text-align: center;
      vertical-align:  middle;
      line-height: 1.2;
      white-space: normal;
    }

    .mini th .th-wrap {
      white-space: normal;
    }

    /* ── Ligne en cours de lecture ───────────────────────── */
    .mini tbody tr.playing-row td {
      color: var(--heading) !important;
    }

    .flex-container + .flex-container {
        margin-top: 0.5rem;
      }

    .grid4 {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }

    /* On “déconteneurise” chaque bloc pour que <table> et <div id="staffX">
       deviennent des items indépendants de la grille.                     */
    .grid4.stacked > div {
      display: contents;
    }

    /* Chaque portée doit occuper toute la ligne pour être bien lisible */
    .grid4.stacked [id^="staff"] {
      grid-column: 1 / -1;      /* pleine largeur */
      margin-top: .5rem;
      order: 1;                 /* les portées passent APRÈS les tableaux */
    }

    /* Les mini-tableaux restent en 1ʳᵉ ligne, côte à côte */
    .grid4.stacked table.mini { order: 0; }

    .grid4 > div {
      min-width: 0;
      max-width: 100%;
      overflow: visible;
      display: flex;
      flex-direction: column;
    }

    .grid4 svg {
      max-width: 100%;
      height: auto;
      display: block;
    }

    /* Responsive – 2 colonnes sous 1024px, 1 colonne sous 600px */
    @media (max-width: 1024px) {
      .grid4 {
        grid-template-columns: repeat(2, 1fr);
      }
    }

    @media (max-width: 600px) {
      .grid4 {
        grid-template-columns: 1fr;
      }
    }

    .bit-grids label {
      font-weight: bold;
      font-size: 0.9rem;
      margin-top: 0.8rem;
      display: block;
    }

    /* même hauteur pour toutes les grilles
      (96 px = 12 px d’en‑tête + 4 × 16 px de pilule) */
    .bit-grids svg {
      width: 100%;
      height: 96px;
      margin-bottom: 1rem;
      display: block;
    }

    #note-grids > div {
      min-width: 0;        /* permet aux enfants de shrinker */
      max-width: 100%;     /* empêche le débordement */
      overflow-x: auto;    /* ajoute un scroll horizontal si vraiment trop large */
    }

    #staff-wrapper {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .th-wrap {
      display: inline-block;
      white-space: normal;
      line-height: 1.1;
      font-size: 0.75rem;
      text-align: center;
    }

    #ulid-decode {
      margin-top: 1rem;
      text-align: center;
      font-family: monospace;
    }

    .nibble-line {
      display: flex;
      justify-content: center;
      gap: 0.25rem;
      margin: 0.3rem 0;
      flex-wrap: wrap;
    }

    .nibble-line span {
      display: inline-block;
      width: 4ch;
      text-align: center;
    }

  </style>

</head>

<body>

  <header id="nav-container" class="header-nav-container"></header>

  <main class="page-wrapper" role="main">

    <h1>🎶 ULID Music</h1>
    <section id="ulid-controls">
      <div class="action-container flex-container">
        <div class="group">
          <button type="button" id="ulid-now"
                  aria-label="Générer un ULID à l’horodatage courant">
            <span aria-hidden="true">⏲️</span> Maintenant
          </button>
          <button type="button" id="ulid-random"
                  aria-label="Générer un ULID aléatoire">
            <span aria-hidden="true">🎲</span> ULID aléatoire
          </button>
        </div>
      </div>
      <div id="ulid-row" class="flex-container">
        <div class="group">
          <label for="ulid-input">ULID :</label>
          <input id="ulid-input" placeholder="26 car. ULID (Crockford)" />
          <div id="ulid-status" style="margin-top:.5rem;"></div>
        </div>
        <div class="group">
          <pre id="ulid-ts-preview" class="code-block ts-preview"
              style="white-space:nowrap; margin-left:0;">
            📆 Date : —  
          </pre>
        </div>
      </div>
    </section>

    <h2>🎵 Notes & 🥁 Rythme</h2>
    <label>🪜 Conversion ULID -> Binaire (nibbles) -> Valeur -> Note</label>
    <section id="ulid-decode" class="aligned-decode hidden">
      <div class="nibble-line" id="nibbles-binary"></div>
      <div class="nibble-line" id="nibbles-values"></div>
      <div class="nibble-line" id="nibbles-notes"></div>
    </section>

    <section>
      <div class="bit-grids">
        <label>🧩 Nibbles</label>
        <svg id="nibbles-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits des nibbles ULID"></svg>
        <label>🔁 Inversés</label>
        <svg id="reversed-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits des nibbles inversés"></svg>
        <label>🧮 XOR Nibbles^Inversés</label>
        <svg id="xor-bits" viewBox="0 0 320 64" preserveAspectRatio="none" aria-label="Bits XOR nibbles"></svg>
        <label>⚡ XOR adaptatif b0^b2 ou b1^b3</label>
        <svg id="xor-adaptive" viewBox="0 0 320 16" preserveAspectRatio="none" aria-label="XOR adaptatif"></svg>
      </div>
      <div>
        <pre id="summary" class="code-block" style="white-space:pre-wrap; font-size:.9rem; margin-bottom:1rem;">—</pre>
      </div>
    </section>

    <section id="music-controls">
      <h2>🎛️ Sonorités</h2>
      <div class="flex-container">
        <div class="group">
          <label>Instrument :
            <select id="instrumentSel">
              <option value="piano" selected>Piano</option>
              <option value="marimba">Marimba</option>
              <option value="strings">Cordes</option>
              <option value="synth">Synthé</option>
              <option value="woodwind">Bois</option>
            </select>
          </label>
          <label>Octave :
            <select id="octaveShift">
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
              <option value="5">5</option>
              <option value="6">6</option>
            </select>
          </label>
        </div>
        <div class="group">
          <label for="tempoBpm">BPM :
            <input type="number" id="tempoBpm" min="20" max="300" step="1" value="75"/>
          </label>
          <label for="tempoDur">Durée d’une noire (s) :
            <input type="number" id="tempoDur" step="0.01" min="0.2" max="3" value="0.8"/>
          </label>
        </div>
        <div class="group">
          <label>Accords :
            <select id="chordsSel">
              <option value="none" selected>Aucun</option>
              <option value="power">Quintes (power chord)</option>
              <option value="triad">Triades</option>
              <option value="seventh">Septièmes</option>
            </select>
          </label>
          <label>Arpège :
            <select id="arp">
              <option value="none" selected>Aucun</option>
              <option value="up">Montant</option>
              <option value="down">Descendant</option>
              <option value="updown">Montant & descendant</option>
              <option value="random">Aléatoire</option>
            </select>
          </label>
        </div>
      </div>
    </section>

    <section id="player-controls">
      <h2>▶️ Lecture</h2>
      <pre id="note-sequence" class="code-block" style="white-space:pre-wrap; font-size:.9rem; margin-bottom:0.5rem;">🎵 Séquence :<br> —</pre>
      <div class="action-container flex-container">
        <div class="group">
          <button type="button" id="play"  aria-label="Lire la séquence">
            <span aria-hidden="true">▶</span> Jouer
          </button>
          <button type="button" id="pause" aria-label="Mettre la lecture en pause">
            <span aria-hidden="true">⏸</span> Pause
          </button>
          <button type="button" id="stop"  aria-label="Arrêter la lecture">
            <span aria-hidden="true">⏹</span> Stop
          </button>
        </div>
      </div>
    </section>

    <h2>🎼 Visualisation</h2>

    <section>
      <div class="grid4" id="note-grids">
        <!-- répété 4× -->
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouées</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl0"></tbody></table>
          <div id="staff0"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouées</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl1"></tbody></table>
          <div id="staff1"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouées</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl2"></tbody></table>
          <div id="staff2"></div>
        </div>
        <div>
          <table class="mini"><thead>
            <tr><th>#</th><th>Dur.</th><th><span class="th-wrap">Notes jouées</span></th><th>Playing</th></tr>
          </thead><tbody id="tbl3"></tbody></table>
          <div id="staff3"></div>
        </div>
      </div>
    </section>

    <section id="staff-wrapper" class="staff-wrapper"></section>

    <section>
      <h2>🧠 Démarche de génération</h2>
      <ol style="line-height:1.6">
        <li>
          <strong>🔢 ULID → 128 bits → nibbles</strong><br />
          L’ULID est une chaîne de 26 caractères encodés en base32 Crockford (5 bits par caractère).<br />
          Seuls les <strong>128 premiers bits</strong> (sur les 130 possibles) sont conservés,
          puis découpés en <strong>32 groupes de 4 bits</strong>, appelés <em>nibbles</em>.<br />
          Chaque nibble représente une valeur entre 0 et 15.
        </li>
        <li>
          <strong>🎵 Note = valeur du nibble</strong><br />
          Chaque valeur est associée à une note musicale parmi une gamme de <strong>16 notes fixes</strong>,
          ajustée selon l’octave sélectionnée.
        </li>
        <li>
          <strong>🧮 Rythme = XOR adaptatif</strong><br />
          Pour chaque nibble en position <code>i</code>, on calcule :<br />
          → un <strong>XOR</strong> entre sa valeur et celle du nibble symétrique en position
          <code>31 - i</code><br />
          → puis on extrait un seul bit de ce résultat selon <code>i</code> :
          <ul>
            <li>Si <code>i</code> est pair → <code>b1 ^ b3</code></li>
            <li>Si <code>i</code> est impair → <code>b0 ^ b2</code></li>
          </ul>
          Ce bit détermine la durée :
          <code>0</code> → <strong>croche</strong> (1/8) • <code>1</code> → <strong>double-croche</strong> (1/16)
        </li>
        <li>
          <strong>📊 Statistiques rythmiques</strong><br />
          Un encart récapitule :
          <ul>
            <li>⏱️ la durée totale estimée</li>
            <li>🎼 le nombre total de battements</li>
            <li>⚖️ la répartition rapide / lente</li>
          </ul>
        </li>
        <li>
          <strong>🎼 Visualisation</strong><br />
          Chaque note est affichée :
          <ul>
            <li>📋 dans un tableau (avec valeur, durée, accord, arpège)</li>
            <li>🎶 sur une portée (clef et durée réelle, via VexFlow)</li>
          </ul>
          Les notes sont groupées par blocs de 8, et les portées s’adaptent automatiquement à leur densité.
        </li>
        <li>
          <strong>▶️ Lecture musicale</strong><br />
          La lecture déclenche :
          <ul>
            <li>🔈 la lecture audio synchronisée</li>
            <li>📚 la surbrillance temps réel des notes</li>
            <li>🧭 le respect du tempo et des durées définies</li>
          </ul>
        </li>
      </ol>
    </section>

  </main>

  <footer>ulid-worker • Codé avec 💚 par Raphaël et 🤖 • Licence MIT</footer>

  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.5/build/cjs/vexflow.js"></script>

  <script type="module">

    /* ===== Constantes & tables ===== */
    const $ = id => document.getElementById(id);


    /*──────────────────────────┐
    │  ÉTAT GLOBAL & CONFIG     │
    └──────────────────────────*/
    
    // États principaux (ULID courant, séquence courante, timers, etc.)
    let ULID = "";
    let seq = [];
    let timers = [];
    
    // Indique si une lecture est en cours
    let isPlaying = false;
    
    // Octave courante « gelée » pour la lecture en cours (null = pas de lecture)
    let playbackBaseOctave = null;
    
    // Mémo pour l’instrument courant et la promesse de chargement
    let currentSampler = null;
    let currentSamplerReady = Promise.resolve();
    
    // Mémo pour surbrillance
    let lastHighlight = null;
    let lastRow = null;
    
    // Flags liés à l’UI (pending instrument, update visuel différé)
    let pendingInstrument = null;
    let pendingVisualUpdate = false;
    
    // Flag pause lecture
    let isPaused = false;
    
    // Constantes de configuration
    const crock = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    
    // Table de cache pour les gammes 16 notes
    const _tbl16Cache = Object.create(null);
    
    // Dictionnaire des définitions d’accords
    const chordDefs = {
      none   : [0],
      power  : [0,4],        // 1‑5
      triad  : [0,2,4],      // 1‑3‑5
      seventh: [0,2,4,6]     // 1‑3‑5‑7
    };
    
    // Liste et configuration des instruments
    const instrumentFiles = {
      marimba: {
        base: "./samples/Samples_Marimba/",
        files: {
          "A2": "A2.80966957.mp3",
          "A3": "A3.cc7d0a4b.mp3",
          "A4": "A4.f93d2aa3.mp3",
          "A5": "A5.c4c561f2.mp3",
          "A6": "A6.7b7ed4b2.mp3",
          "C2": "C2.2c273809.mp3",
          "C3": "C3.bf6e7680.mp3",
          "C4": "C4.b5cfeca7.mp3",
          "C5": "C5.53bc9580.mp3",
          "C6": "C6.0da1964c.mp3",
        }
      },
      piano: {
        base: "./samples/Samples_Piano/",
        files: {

          "A2": "A2v8.mp3",
          "A3": "A3v8.mp3",
          "A4": "A4v8.mp3",
          "A5": "A5v8.mp3",
          "A6": "A6v8.mp3",
          "A7": "A7v8.mp3",
          "C1": "C1v8.mp3",
          "C2": "C2v8.mp3",
          "C3": "C3v8.mp3",
          "C4": "C4v8.mp3",
          "C5": "C5v8.mp3",
          "C6": "C6v8.mp3",
          "C7": "C7v8.mp3",
          "C8": "C8v8.mp3",
        }
      },
      strings: {
        base: "./samples/Samples_Strings/",
        files: {
          "A2": "A2.32eab706.mp3",
          "A3": "A3.ead476da.mp3",
          "A4": "A4.79029edf.mp3",
          "A5": "A5.bda0be10.mp3",
          "A6": "A6.e1417bdc.mp3",
          "C2": "C2.4df4b0a2.mp3",
          "C3": "C3.9a2d50aa.mp3",
          "C4": "C4.31bc4670.mp3",
          "C5": "C5.4f7ad86c.mp3",
          "C6": "C6.655fa406.mp3",
        }
      },
      synth: {
        base: "./samples/Samples_Synth/",
        files: {
          "A2": "A2.d39e6a1e.mp3",
          "A3": "A3.2583ee7f.mp3",
          "A4": "A4.02c12517.mp3",
          "A5": "A5.20b412cf.mp3",
          "A6": "A6.46657279.mp3",
          "C2": "C2.9e3b6556.mp3",
          "C3": "C3.54c3718a.mp3",
          "C4": "C4.3eba7397.mp3",
          "C5": "C5.731ab831.mp3",
          "C6": "C6.5b196566.mp3",
        }
      },
      woodwind: {
        base: "./samples/Samples_Woodwind/",
        files: {
          "A2": "A2.c94f91ab.mp3",
          "A3": "A3.44853c04.mp3",
          "A4": "A4.4849e599.mp3",
          "A5": "A5.1b9b02ba.mp3",
          "A6": "A6.8f960bfa.mp3",
          "C2": "C2.e247094b.mp3",
          "C3": "C3.254276f0.mp3",
          "C4": "C4.858d5d62.mp3",
          "C5": "C5.c7a85606.mp3",
          "C6": "C6.a1140119.mp3",
        }
      },
    };
    
    const instrumentBehavior = {
      piano:    "full",
      marimba:  "full",
      strings:  "full",
      synth:    "cut",
      woodwind: "cut"
    };


    /*──────────────────────────┐
    │  HELPERS PURS             │
    └──────────────────────────*/
    
    // Conversion ULID en 128 bits binaires (string)
    function toBits(ulid) {
      return ulid
        .split("")
        .map(c => crock.indexOf(c).toString(2).padStart(5, "0"))
        .join("")
        .slice(0, 128);
    }
    
    // Coupe en 32 nibbles (tableau de 32× "0000" à "1111")
    function chunk4(bits) {
      return Array.from({ length: 32 }, (_, i) => bits.slice(i*4, i*4 + 4));
    }
    
    // Génération d’un ULID conforme (timestamp ou aléa)
    function makeUlid(ts) {
      const crock = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
      let ts48;
      if (ts === 'random') {
        ts48 = BigInt(0);
        for (let i = 0; i < 6; i++) {
          ts48 = (ts48 << 8n) | BigInt(Math.floor(Math.random() * 256));
        }
      } else {
        let tsVal;
        if (typeof ts === "number" && isFinite(ts)) {
          tsVal = Math.floor(ts);
        } else if (typeof ts === "string" && /^\d+$/.test(ts)) {
          tsVal = Math.floor(Number(ts));
        } else if (ts === undefined || ts === null) {
          tsVal = Date.now();
        } else {
          tsVal = Date.now();
        }
        ts48 = BigInt(tsVal) & 0xFFFFFFFFFFFFn;
      }
      let tsBase32 = "";
      let v = ts48;
      for (let i = 0; i < 10; i++) {
        tsBase32 = crock[Number(v % 32n)] + tsBase32;
        v = v / 32n;
      }
      let rand = BigInt(0);
      for (let i = 0; i < 10; i++) {
        rand = (rand << 8n) | BigInt(Math.floor(Math.random() * 256));
      }
      let randBase32 = "";
      v = rand;
      for (let i = 0; i < 16; i++) {
        randBase32 = crock[Number(v % 32n)] + randBase32;
        v = v / 32n;
      }
      return tsBase32 + randBase32;
    }
    function makeUlidNow()    { return makeUlid(Date.now()); }
    function makeUlidRandom() { return makeUlid(); }
    
    // Table de 16 notes (gamme de base, mémoïsée par octave)
    function getTable16(baseOctave = 4){
      if (_tbl16Cache[baseOctave]) return _tbl16Cache[baseOctave];
      const base = ["C","D","E","F","G","A","B"];
      const out  = [];
      let   oct  = baseOctave;
      for(let i=0;i<16;i++){
        out.push(base[i%7] + oct);
        if(base[i%7]==="B") oct++;
      }
      return (_tbl16Cache[baseOctave] = out);
    }
    
    // Accords : retourne la liste des notes de l’accord, modulo 16
    function chordify(note, type, table){
      const idx = table.indexOf(note);
      if (idx === -1) return [note];
      return chordDefs[type].map(d => table[(idx + d) % table.length]);
    }
    
    // XOR adaptatif : logique de rythme rapide/lent
    function xorAdaptiveFrom(val, rev, i) {
      const x = val ^ rev;
      const b0 = (x >> 0) & 1;
      const b1 = (x >> 1) & 1;
      const b2 = (x >> 2) & 1;
      const b3 = (x >> 3) & 1;
      return (i % 2 === 0) ? (b1 ^ b3) : (b0 ^ b2);
    }
    
    // Statistiques rythmiques (nombre de rapides/lentes/battements)
    function calcRhythmStats(seq) {
      const fast  = seq.filter(o => o.fast).length;
      const slow  = seq.length - fast;
      const beats = seq.reduce((s, o) => s + (o.fast ? 1 : 2), 0);
      return { fast, slow, beats };
    }
    
    // Arpégiateur (ordre de jeu des notes selon motif)
    function arp(arr, pattern) {
      switch (pattern) {
        case "up":      return arr;
        case "down":    return [...arr].reverse();
        case "updown":  return [...arr, ...[...arr].reverse()];
        case "random":  return [...arr].sort(() => Math.random() - 0.5);
        default:        return arr;
      }
    }
    
    // Format date humanisé (optionnel ici)
    function formatFullDate(isoString) {
      const d = new Date(isoString);
      const days = ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"];
      const months = ["janvier", "février", "mars", "avril", "mai", "juin",
                      "juillet", "août", "septembre", "octobre", "novembre", "décembre"];
      const dayName = days[d.getUTCDay()];
      const day     = d.getUTCDate().toString().padStart(2, "0");
      const month   = months[d.getUTCMonth()];
      const year    = d.getUTCFullYear();
      const hour    = d.getUTCHours().toString().padStart(2, "0");
      const minute  = d.getUTCMinutes().toString().padStart(2, "0");
      const second  = d.getUTCSeconds().toString().padStart(2, "0");
      const ms      = d.getUTCMilliseconds().toString().padStart(3, "0");
      return `${dayName} ${day} ${month} ${year} à ${hour}:${minute}:${second}.${ms} UTC`;
    }

    // Anti-rebond pour les inputs
    const debounce = (fn, d = 300) => {
      let t; return (...a)=>{ clearTimeout(t); t=setTimeout(fn, d, ...a); };
    };
    
    // Conversion ULID → séquence complète (tableau d’objets {val, fast})
    function ulidToSequence(v) {
      const bits    = toBits(v);
      const nibbles = chunk4(bits);
      const vals    = nibbles.map(b => parseInt(b, 2));
      const revs    = [...vals].reverse();
      return vals.map((val, i) => ({
        val,
        fast: xorAdaptiveFrom(vals[i], revs[i], 31 - i) === 1
      }));
    }
    
    // Renvoie l’octave courante (figée pendant lecture, sinon du select)
    const getBaseOctave = () =>
          (playbackBaseOctave !== null)
            ? playbackBaseOctave
            : parseInt($("octaveShift").value, 10);


    /*──────────────────────────┐
    │  HELPERS MÉTIER (audio, sample)
    └──────────────────────────*/
    
    // Chargement asynchrone de l’instrument/sampler
    async function loadSampler(type) {
      const prevSampler = currentSampler;
      const def = instrumentFiles[type];
      const baseOct = parseInt($("octaveShift").value, 10);
      const table16 = getTable16(baseOct);
      const neededOctaves = [...new Set(
        table16.map(n => parseInt(n.match(/\d+$/)[0], 10))
      )];
      const files = {};
      Object.entries(def.files).forEach(([note, file]) => {
        const oct = parseInt(note.match(/\d+$/)[0], 10);
        if (neededOctaves.includes(oct)) {
          files[note] = file;
        }
      });
      let resolveReady;
      const samplerReady = new Promise(r => (resolveReady = r));
      const sampler = new Tone.Sampler({
        urls:    files,
        baseUrl: def.base,
        onload: () => {
          if (prevSampler) prevSampler.dispose();
          resolveReady();
        }
      });
      const volume  = new Tone.Volume(-8);
      const reverb  = new Tone.Reverb({ decay: 2, wet: 0.3 });
      const limiter = new Tone.Limiter(-1);
      sampler.chain(volume, reverb, limiter, Tone.Destination);
      currentSampler      = sampler;
      currentSamplerReady = samplerReady;
      return currentSamplerReady;
    }


    /*────────────────────────────┐
    │  RENDERING & UI             │
    └────────────────────────────*/
    
    // Affiche la grille binaire (SVG) pour chaque niveau (nibbles, inversés, etc.)
    function renderBitGrid(intArray, svgId, adaptiveFn = null) {
      const svg = $(svgId);
      svg.innerHTML = "";

      /* ——— Dimensions dynamiques ——— */
      const n       = 32;
      const headerH = 12;        /* bandeau numéros */
      const lblW    = 22;        /* marge gauche b0‑b3 */
      const gap     = 4;         /* px entre groupes de 8 */

      /* largeur réelle du conteneur (100 % du parent) */
      const cssW   = svg.clientWidth || 320;
      const pillW  = Math.floor((cssW - lblW - 3 * gap) / n);
      const pillH  = 16;         /* hauteur fixe lisible */

      const totalW = lblW + n * pillW + 3 * gap;  /* == cssW */
      const totalH = headerH + (adaptiveFn ? pillH : 4 * pillH);

      svg.setAttribute("viewBox", `0 0 ${totalW} ${totalH}`);
      svg.setAttribute("preserveAspectRatio", "xMidYMid meet");

      /* ——— Contenu ——— */
      intArray.forEach((val, i) => {
        const bits = val.toString(2).padStart(4, "0").split("").map(Number);
        const g    = document.createElementNS("http://www.w3.org/2000/svg", "g");

        const x = lblW + i * pillW + Math.floor(i / 8) * gap;
        g.setAttribute("transform", `translate(${x},${headerH})`);

        if (adaptiveFn) {
          const v = adaptiveFn(val, i);
          const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          r.setAttribute("x", 0);
          r.setAttribute("y", 0);
          r.setAttribute("width", pillW - 1);
          r.setAttribute("height", pillH);
          r.setAttribute("rx", "1");
          r.setAttribute("ry", "1");
          r.setAttribute("fill", v ? "var(--bit-xor-adapt)" : "var(--bit-off)");
          g.appendChild(r);
        } else {
          bits.forEach((b, j) => {
            const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            r.setAttribute("x", 0);
            r.setAttribute("y", j * pillH + 0.5);
            r.setAttribute("width", pillW - 1);
            r.setAttribute("height", pillH - 1);
            r.setAttribute("rx", "1");
            r.setAttribute("ry", "1");
            r.setAttribute("fill", b ? "var(--bit-on)" : "var(--bit-off)");

            const needBorder =
              (i % 2 === 0 && (j === 1 || j === 3)) ||
              (i % 2 === 1 && (j === 0 || j === 2));
            if (svgId === "xor-bits" && needBorder) {
              r.setAttribute("stroke", "var(--bit-xor-adapt)");
              r.setAttribute("stroke-width", "1");
            }

            g.appendChild(r);
          });

        }
        svg.appendChild(g);
      });

      /* ——— Numérotation des colonnes 32 ➜ 1 ——— */
      for (let i = 0; i < n; i++) {
        const x = lblW + i * pillW + Math.floor(i / 8) * gap + pillW / 2;
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", x);
        t.setAttribute("y", headerH - 2);
        t.setAttribute("text-anchor", "middle");
        t.setAttribute("font-size", "10");
        t.setAttribute("fill", "var(--text)");
        t.textContent = n - i;            /* 32 à gauche → 1 à droite */
        svg.appendChild(t);
      }

      /* ——— Labels de ligne (b0‥b3) ——— */
      if (!adaptiveFn) {
        ["b0", "b1", "b2", "b3"].forEach((lbl, j) => {
          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", lblW - 2);
          t.setAttribute("y", headerH + j * pillH + pillH / 2 + 4);
          t.setAttribute("text-anchor", "end");
          t.setAttribute("font-size", "10");
          t.setAttribute("fill", "var(--text)");
          t.textContent = lbl;
          svg.appendChild(t);
        });
      }
    }
    
    // Affiche une portée VexFlow, avec surbrillance éventuelle
    function renderStaff(containerId, blockSeq, table16,
                        highlightIdx = -1, forcedOctave = null){
      try {
        const VF = window.Vex?.Flow;
        if (!VF) return;
        const container = $(containerId);
        if (!container) return;
        container.replaceChildren();
      
        const parentW = container.clientWidth;
        const vf = new VF.Factory({ renderer: { elementId: containerId, width: parentW, height: 140 } });
        const score = vf.EasyScore();
        const sys   = vf.System();
      
        const baseOctave = forcedOctave !== null ? forcedOctave : getBaseOctave();
        const clef = baseOctave <= 2 ? "bass" : baseOctave === 3 ? "alto" : "treble";
      
        const chordT   = $("chordsSel").value;
        const arpStyle = $("arp").value;
        const parts = [];
        blockSeq.forEach(o => {
          const root       = table16[o.val];
          const dur        = o.fast ? "16" : "8";
          const chordNotes = chordify(root, chordT, table16);
          if (chordT !== "none" && arpStyle === "none") {
            parts.push(`(${chordNotes.map(n => n.toLowerCase()).join(" ")})/${dur}`);
          } else if (arpStyle !== "none" && chordNotes.length > 1) {
            const ordered =
              arpStyle === "down"   ? [...chordNotes].reverse() :
              arpStyle === "random" ? arp([...chordNotes], "random") :
              chordNotes;
            ordered.forEach(n => parts.push(`${n.toLowerCase()}/${dur}`));
          } else {
            parts.push(`${root.toLowerCase()}/${dur}`);
          }
        });
        const sliceString = parts.join(", ");
        let beats16 = 0;
        parts.forEach(tok => { beats16 += tok.endsWith("/16") ? 1 : 2; });
        const notesArr = score.notes(sliceString);
        const beams = VF.Beam.generateBeams(notesArr);
        beams.forEach(beam => vf.Beam({ notes: beam.getNotes() }));
        const voice = score.voice(notesArr, {
          time: { num_beats: beats16, beat_value: 16 },
          strict: false
        });
        voice.setMode(VF.Voice.Mode.SOFT);
        sys.addStave({
          voices: [voice],
          time_signature: `${beats16}/16`
        }).addClef(clef);
        vf.draw();
        const gNotes = container.querySelectorAll('.vf-stavenote');
        gNotes.forEach(g => g.classList.remove("note-play"));
        if (highlightIdx >= 0 && gNotes[highlightIdx]) gNotes[highlightIdx].classList.add("note-play");
        return parts.length;
      } catch (err) {
        // log mais ne bloque pas tout le rendu
        if (window?.console) console.error("Erreur renderStaff:", err);
        return 0;
      }
    }
    
    // Dessine les 4 portées et décide de l’empilement
    function draw(seq){
      const baseOct = (playbackBaseOctave ?? getBaseOctave());
      const table16 = getTable16(baseOct);

      /* 1️⃣  Décide d’abord si l’on empile ou non */
      let maxNotes = 0;
      for (let b = 0; b < 4; b++) {
        const cnt = countBlockNotes(seq.slice(b * 8, b * 8 + 8), table16);
        if (cnt > maxNotes) maxNotes = cnt;
      }
      const grids = $("note-grids");
      (maxNotes > 8) ? grids.classList.add("stacked")
                     : grids.classList.remove("stacked");

      /* 2️⃣  Puis on (re)dessine chacune des portées */
      for (let b = 0; b < 4; b++) {
        const blockSeq = seq.slice(b * 8, b * 8 + 8);
        const fo = (playbackBaseOctave !== null ? playbackBaseOctave : null);
        renderStaff("staff" + b, blockSeq, table16, -1, fo);
      }
    }
    
    // Surbrillance temps réel tableau + partition
    function highlightNote(i, subOffset = 0){

      const arpStyle = $("arp").value;
      const chordT = $("chordsSel").value;
      const baseOctave = getBaseOctave();
      const table16 = getTable16(baseOctave);
      const isUpdown = arpStyle === "updown";
      const realIdx = isUpdown && i >= seq.length ? 2 * seq.length - i - 1 : i;

      /* O(1) : on retire l’ancienne ligne au lieu d’un querySelectorAll */
      if (lastRow) lastRow.classList.remove('playing-row');

      const cell = document.getElementById("play-cell" + realIdx);
      if (cell) {
        const row = cell.closest("tr");
        row.classList.add("playing-row");
        lastRow = row;
        cell.classList.add("playing");

        const notes = JSON.parse(row.dataset.notes);

        const tid = setTimeout(() => cell.classList.remove("playing"), 200);
        timers.push(tid);
      }

      /* Portée ----------------------------------------------------- */
      const bloc = Math.floor(realIdx / 8);   /* realIdx = 0-31 même en descente */
      if (bloc > 3) return;                   /* on n’a que 4 portées */
      /* O(1) : retire l’ancienne surbrillance */
      if (lastHighlight) lastHighlight.classList.remove('note-play');

      /* Redessine la portée miniature avec la note active */
      drawMini(bloc, realIdx % 8, seq, subOffset, table16)

      /* Mémorise la nouvelle tête mise en évidence */
      const container = $('staff' + bloc);
      lastHighlight   = container.querySelector('.note-play');
    }
    
    // Met à jour la direction des flèches de notes dans les tables (up/down)
    function updateArrowDirection(isDescending) {
      document.querySelectorAll("tr[data-i]").forEach(tr => {
        const i = tr.dataset.i;
        const notes = JSON.parse(tr.dataset.notes);
        const td = document.getElementById("notes-" + i);
        if (td && notes.length > 1) {
          td.textContent = (isDescending ? [...notes].reverse() : notes).join(isDescending ? " ← " : " → ");
        }
      });
    }
    
    // Calcule le nombre de têtes de notes dans un bloc (pour layout grille/stack)
    function countBlockNotes(blockSeq, table16){
      const chordT   = $("chordsSel").value;
      const arpStyle = $("arp").value;
      let cnt = 0;
      blockSeq.forEach(o => {
        const root       = table16[o.val];
        const chordNotes = chordify(root, chordT, table16);
        if (chordT !== "none" && arpStyle === "none") {
          cnt += 1;                       /* accord simultané = 1 tête */
        } else if (arpStyle !== "none" && chordNotes.length > 1) {
          cnt += chordNotes.length;       /* arpège = n têtes */
        } else {
          cnt += 1;
        }
      });
      return cnt;
    }
    
    // Affiche un mini rendu de portée sur staffX (pour highlight)
    function drawMini(block, seqIdxInBlock, seq, subOffset = 0, table16){
      const blockSeq = seq.slice(block * 8, block * 8 + 8);
      const chordT   = $("chordsSel").value;
      const arpStyle = $("arp").value;

      /* Calcule le décalage (en # de têtes) avant l’index à mettre en surbrillance */
      let noteIdx = 0;
      for (let k = 0; k < seqIdxInBlock; k++) {
        const root       = table16[blockSeq[k].val];
        const chordNotes = chordify(root, chordT, table16);
        if (chordT !== "none" && arpStyle === "none") {
          noteIdx += 1;                          /* accord simultané = 1 tête */
        } else if (arpStyle !== "none" && chordNotes.length > 1) {
          noteIdx += chordNotes.length;          /* arpège = n têtes */
        } else {
          noteIdx += 1;                          /* note simple */
        }
      }

      noteIdx += subOffset;               /* 2ᵉ, 3ᵉ note de l’arpège, … */
      const fo = (playbackBaseOctave !== null ? playbackBaseOctave : null);
      renderStaff("staff" + block, blockSeq, table16, noteIdx, fo);
    }
    
    // Rendu complet des tableaux + staff
    function renderTablesAndStaff(seq, table16){

      const chordT = $("chordsSel").value;
      const isUpdown = $("arp").value === "updown";
      const totalBlocks = 4;

      // 1. Vider les tableaux
      for (let t = 0; t < totalBlocks; t++) {
        const tid = "tbl" + t;
        if ($(tid)) $(tid).innerHTML = "";
      }
      $("staff-wrapper").innerHTML = "";

      // 2. Remplir ligne par ligne
      seq.forEach((o, i) => {
        const b = o.val.toString(2).padStart(4, "0");
        const tbl  = "tbl" + Math.floor(i / 8);
        const dur  = o.fast ? "1/16" : "1/8";
        const rowIdx = i + 1;
  
        const root = table16[o.val];
        const chordNotes = chordify(root, chordT, table16);
  
        const arpStyle = $("arp").value;
        let noteDisplay = "";
  
        if (chordNotes.length === 1 || arpStyle === "none") {
          noteDisplay = chordNotes[0];
        } else if (arpStyle === "updown") {
          // on n'affiche que la phase montante
          noteDisplay = chordNotes.join(" → ");
        } else {
          const ordered = arp(chordNotes, arpStyle);
          noteDisplay = ordered.join(" → ");
        }
  
        const row  = `
          <tr data-i="${i}" data-notes='${JSON.stringify(chordNotes)}'>
            <td>${rowIdx}</td>
            <td>${dur}</td>
            <td id="notes-${i}">${noteDisplay}</td>
            <td class="playing-col" id="play-cell${i}"></td>
          </tr>`;
        $(tbl).insertAdjacentHTML("beforeend", row);
      });

      /* Un seul rendu – évite les 4 portées supplémentaires */
      draw(seq);
    }
    
    // Ligne de nibbles binaire, valeur, note (pour validateUlid)
    function renderNibbleLine(target, contentArr) {
      const frag = document.createDocumentFragment();
      contentArr.forEach(txt => {
        const span = document.createElement("span");
        span.textContent = txt;
        frag.appendChild(span);
      });
      target.innerHTML = "";
      target.appendChild(frag);
    }
    
    // Rafraîchit tout l’affichage (octave/accord/arpège modifiés)
    function refreshDisplayAfterOctaveChange() {
      if (isPlaying) return;
      if (ULID && seq.length > 0) {
        const baseOctave = playbackBaseOctave ?? getBaseOctave();
        const table16    = getTable16(baseOctave);
        $("note-sequence").textContent =
          "🎵 Séquence :\n" + seq.map(o => table16[o.val]).join(", ");
        renderTablesAndStaff(seq, table16);
      }
    }
    
    // Synchronise BPM <-> Durée d’une noire
    function syncTempoFields(source) {
      const bpmInput = $("tempoBpm");
      const durInput = $("tempoDur");
      if (source === "bpm") {
        const bpm = parseFloat(bpmInput.value);
        if (bpm > 0) durInput.value = (60 / bpm).toFixed(2);
      } else {
        const dur = parseFloat(durInput.value);
        if (dur > 0) bpmInput.value = Math.round(60 / dur);
      }
    }

    // Génère un nouvel ULID, le place dans le champ, valide l'entrée
    function newUid(){
      const id = makeUlidNow();
      $("ulid-input").value = id;
      validateUlid(id);
    }
    
    // Réinitialisation complète de la lecture et de l’affichage
    function clearAll(time) {
      if (typeof time === "number") Tone.Transport.stop(time);
      else Tone.Transport.stop();
      Tone.Transport.cancel();
      timers.forEach(clearTimeout);
      timers.length = 0;
      if (lastHighlight) lastHighlight.classList.remove("note-play");
      lastHighlight = null;
      document.querySelectorAll("tr.playing-row")
              .forEach(r => r.classList.remove("playing-row"));
      $("pause").textContent = "⏸ Pause";
      $("pause").disabled    = true;
    }
    
    // Validation d’un ULID (appel au worker + maj UI)
    async function validateUlid(v) {
      v = v.trim().toUpperCase();
      $("ulid-input").value = v;
      const baseOctave    = getBaseOctave();
      const table16       = getTable16(baseOctave);
      const binLine       = $("nibbles-binary");
      const valLine       = $("nibbles-values");
      const noteLine      = $("nibbles-notes");
      const statusEl = $("ulid-status");
      let   res, data;
      try{
        res  = await fetch('/ulid?check=' + encodeURIComponent(v));
        data = await res.json();
      }catch(err){
        statusEl.textContent = "⛔ Erreur réseau ("+err.message+")";
        statusEl.style.color = "var(--error,#f00)";
        $("ulid-ts-preview").textContent = "📆 Date : —";
        return;
      }
      if (res.ok && data.conform) {
        $("play").disabled = false;
        statusEl.textContent = "✅ ULID conforme";
        statusEl.style.color = "var(--success,#00ff00)";
        $("ulid-ts-preview").textContent = "📆 Date : " + formatFullDate(data.ts);
        clearAll();
        $("note-grids").style.display = "grid";
        seq = ulidToSequence(v);
        const vals = seq.map(o => o.val);
        const revs = [...vals].reverse();
        const xors = vals.map((v, i) => v ^ revs[i]);
        ["nibbles-bits", "reversed-bits", "xor-bits", "xor-adaptive"]
          .forEach(id => $(id).innerHTML = "");
        renderBitGrid(vals,     "nibbles-bits");
        renderBitGrid(revs,     "reversed-bits");
        renderBitGrid(xors,     "xor-bits");
        renderBitGrid(
          [...xors].reverse(),
          "xor-adaptive",
          (_, i) => xorAdaptiveFrom(vals[31 - i], revs[31 - i], 31 - i)
        );
        const fastCount = seq.filter(o => o.fast).length;
        const slowCount = seq.length - fastCount;
        const beatCount = seq.reduce((s, o) => s + (o.fast ? 1 : 2), 0);
        const tempo = parseFloat($("tempoDur").value);
        const duration = (beatCount * tempo).toFixed(2);
        $("summary").textContent =
          `⏱️ Durée estimée : ${duration} sec\n` +
          `🎼 Battements : ${beatCount} (sur ${seq.length * 2} max)\n` +
          `⚖️ Rythme : ${fastCount} rapides / ${slowCount} lentes`;
        ULID = v;
        renderNibbleLine(binLine, vals.map(val => val.toString(2).padStart(4, "0")));
        renderNibbleLine(valLine, vals.map(val => val));
        renderNibbleLine(noteLine, vals.map(val => table16[val]));
        $("ulid-decode").classList.remove("hidden");
        $("note-sequence").textContent = "🎵 Séquence :\n" + seq.map(o => table16[o.val]).join(", ");
        for (let b = 0; b < 4; b++) {
          $("tbl" + b).innerHTML   = "";
          $("staff" + b).innerHTML = "";
        }
        renderTablesAndStaff(seq, table16);
      } else {
        $("play").disabled = true;
        statusEl.textContent = "❌ " + (data.error || "");
        statusEl.style.color = "var(--error,#f00)";
        $("ulid-ts-preview").textContent = "📆 Date : —";
        $("note-sequence").textContent = "🎵 Séquence :\n —";
        ["nibbles-bits", "reversed-bits", "xor-bits", "xor-adaptive"]
          .forEach(id => $(id).innerHTML = "");
        $("summary").textContent =
          `⏱️ Durée estimée : — \n` +
          `🎼 Battements : — \n` +
          `⚖️ Rythme : —`;
        $("note-grids").style.display = "none";
      }
    }


    /*────────────────────────────┐
    │  UI : LISTENERS & WORKFLOW  │
    └────────────────────────────*/
    
    // Rafraîchit la séquence à chaque modif de l’accord, arpège ou octave (input mutualisé)
    ['chordsSel','arp','octaveShift']
      .forEach(id =>
        $(id).addEventListener('input', refreshDisplayAfterOctaveChange)
      );
    
    // Validation ULID avec anti-rebond
    $("ulid-input").addEventListener(
      "input",
      debounce(() => {
        validateUlid($("ulid-input").value);
      }, 300)
    );
    
    // Synchronisation BPM / Durée noire
    $("tempoBpm").addEventListener("input", () => syncTempoFields("bpm"));
    $("tempoDur").addEventListener("input", () => syncTempoFields("dur"));
    
    // Boutons ULID random/maintenant
    $("ulid-random").onclick = () => {
      const id = makeUlidRandom();
      $("ulid-input").value = id;
      validateUlid(id);
    };
    $("ulid-now").onclick = () => {
      const id = makeUlidNow();
      $("ulid-input").value = id;
      validateUlid(id);
    };
    
    // Gestion bouton Stop
    $("stop").onclick = () => {
      clearAll();
      isPlaying = false;
      playbackBaseOctave = null;
      ["instrumentSel","octaveShift","chordsSel","arp",
       "tempoBpm","tempoDur"].forEach(id => $(id).disabled = false);
      isPaused = false;
      $("pause").textContent = "⏸ Pause";
      $("pause").disabled = true;
    };
    
    // Lecture : Play
    $("play").onclick = async () => {
      if (!seq || seq.length === 0) return;
      isPlaying = true;
      ["instrumentSel","octaveShift","chordsSel","arp",
       "tempoBpm","tempoDur"].forEach(id => $(id).disabled = true);
      playbackBaseOctave = parseInt($("octaveShift").value, 10);
      const baseOctave   = playbackBaseOctave;
      const table16      = getTable16(baseOctave);
      const transposed = table16;
      await Tone.start();
      if (isPlaying) {
        await new Promise(resolve => {
          Tone.Transport.once("stop", resolve);
          clearAll();
        });
      } else {
        clearAll();
      }
      if (pendingInstrument) {
        await loadSampler(pendingInstrument);
        pendingInstrument = null;
      }
      await currentSamplerReady;
      isPaused = false;
      $("pause").textContent = "⏸ Pause";
      $("pause").disabled = false;
      const chordT = $("chordsSel").value;
      const pat = $("arp").value;
      const seqArr = arp(seq, pat);
      Tone.Transport.cancel();
      updateArrowDirection(false);
      let pos = 0;
      const tempo = parseFloat($("tempoDur").value);
      const isUpdown = pat === "updown";
      const len = seqArr.length;
      const instrument = $("instrumentSel").value;
      const playMode = instrumentBehavior[instrument];
      seqArr.forEach((o, i) => {
        const dur = tempo * (o.fast ? 0.5 : 1);
        Tone.Transport.schedule(t => {
          if (isUpdown && i === Math.floor(len / 2)) {
            updateArrowDirection(true);
          }
        }, pos);
        const note        = transposed[o.val];
        const chordNotes  = chordify(note, chordT, transposed);
        const arpeggiate  = (pat !== "none" && chordT !== "none" && chordNotes.length > 1);
        const isDescending = isUpdown && i >= len / 2;
        const chordSeq = (arpeggiate && isDescending) ? [...chordNotes].reverse() : chordNotes;
        chordSeq.forEach((n, j) => {
          const offset   = arpeggiate ? j * (dur / chordSeq.length) : 0;
          const when     = pos + offset;
          const noteDur  = (playMode === "full") ? undefined : dur / chordSeq.length;
          Tone.Transport.schedule(t => {
            if (playMode === "full") {
              currentSampler.triggerAttack(n, t);
            } else {
              currentSampler.triggerAttackRelease(n, noteDur, t);
            }
          }, when);
          const jAdj = arpeggiate
                       ? (isDescending ? chordSeq.length - 1 - j : j)
                       : 0;
          Tone.Transport.schedule(() => {
            highlightNote(i, jAdj);
          }, when);
        });
        pos += dur;
      });
      Tone.Transport.scheduleOnce((time) => {
        Tone.Transport.stop(time);
        updateArrowDirection(false);
        clearAll(time);
        isPlaying = false;
        playbackBaseOctave = null;
        ["instrumentSel","octaveShift","chordsSel","arp",
         "tempoBpm","tempoDur"].forEach(id => $(id).disabled = false);
        isPaused = false;
        $("pause").textContent = "⏸ Pause";
        $("pause").disabled = true;
      }, pos + tempo);
      Tone.Transport.start("+0");
    };
    
    // Pause/Reprendre
    $("pause").onclick = () => {
      if (Tone.Transport.state === "started") {
        Tone.Transport.pause();
        isPaused = true;
        $("pause").textContent = "▶ Reprendre";
      } else if (Tone.Transport.state === "paused" && isPaused) {
        Tone.Transport.start();
        isPaused = false;
        $("pause").textContent = "⏸ Pause";
      }
    };
    
    
    /*────────────────────────────┐
    │  UI : LISTENERS & WORKFLOW  │
    └────────────────────────────*/

    (async () => {
      await loadSampler("piano");
      newUid();
      $("pause").disabled = true;
      if (!seq || seq.length === 0) $("play").disabled = true;
    })();

  </script>

  <!-- enfin ton script principal -->
  <script type="module" src="./site.js"></script> 

</body>
</html>
