<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>üß¨ ULID Matrix</title>
  
  <!-- Th√®me avant chargement du CSS -->
  <script>
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    document.documentElement.setAttribute("data-theme", prefersDark ? "dark" : "light");
  </script>

  <!-- ton CSS -->
  <link rel="stylesheet" href="/style.css"/>

  <style>

    html, body { margin:0; padding:0; }



    canvas#matrix {
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      background-color: var(--matrix-background);
      visibility: hidden;
      display:block;
      z-index: 0;
    }

    /* -------- Controls -------- */
    .controls {
      position: fixed;
      top:    calc(var(--navbar-height) + 1rem);
      /* cale √† droite de la zone de la navbar (centr√©e, max-width) */
      right:  calc((100% - var(--navbar-max-width)) / 2 + var(--space-xl));
      display: flex;
      gap: var(--space-md);
      z-index: 50;
    }

    .controls button {
      background: transparent;
      border: none;
      padding: 4px;
      font-size: 18px;
      opacity: 0.1;
      transition: opacity 0.2s;
      cursor: pointer;
    }
    .controls button:hover { opacity: 0.6; }

    /* -------- Help box -------- */
    .help {
      position: absolute;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%); /* d√©cale l‚Äô√©l√©ment de 50% de sa largeur vers la gauche, pour le centrer exactement sous son point de r√©f√©rence */
      color: var(--help-color);
      font-size: 1rem;
      background: var(--help-bg, rgba(0, 0, 0, 0.6));
      padding: 0.5rem 1rem;
      border: 1px dashed var(--help-color);
      display: none;
      z-index: 50;
    }

  </style>

</head>

<body>

  <header id="nav-container" class="header-nav-container"></header>

    <main> 

    <!-- Canvas principal -->
    <canvas id="matrix"></canvas>

    <!-- Boutons de contr√¥le -->
    <div class="controls">
      <button type="button" id="fullscreen-btn" aria-label="Plein √©cran avec navbar masqu√©e">üî≥</button>
      <button type="button" id="pause-btn" aria-label="Pause de l'animation">‚è∏Ô∏è</button>
      <button type="button" id="funky-btn" aria-label="Changement de mode">ü™©</button>
      <button type="button" id="fps-btn" aria-label="Vitesse maximale">‚ö°</button>
      <button type="button" id="help-btn" aria-label="Affichage de l'aide">üõü</button>
      </div>
      <!-- Aide sur les raccourcis clavier -->
      <div class="help" id="help-box">
        <ul style="margin:0; padding:0; list-style:none;">
          <li><kbd>F</kbd> : Plein √©cran</li>
          <li><kbd>Space</kbd> : Pause pluie</li>
          <li><kbd>M</kbd> : Mode couleur</li>
          <li><kbd>S</kbd> : Vitesse max</li>
          <li><kbd>H</kbd> : Afficher/Masquer l‚Äôaide</li>
          <li><kbd>ControlLeft</kbd> : Maximise l'affichage des boutons le temps de l'appui</li>
          <li style="margin-top:0.5rem;">Chaque goutte affiche un ULID g√©n√©r√© au moment de sa naissance.</li>
        </ul>
      </div>

    <script type="module">
      import { ulid } from "/module/ulid";

      const canvas = document.getElementById("matrix");
      const ctx = canvas.getContext("2d");

      // Canvas en pixels CSS simples
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;

      const fontSize = 16;
      const chars    = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";

      

      // ‚îÄ‚îÄ 2. Pr√©calcul police & th√®mes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      ctx.font = `${fontSize}px monospace`;  // ‚Üê maintenant apr√®s scale
      let bgColor, textColor, invBgColor;

      /** Inverse une couleur (hex ou rgb) en rgb(255‚àír,255‚àíg,255‚àíb) */
      function invertColor(col) {
        const d = document.createElement('div');
        d.style.color = col;
        document.body.appendChild(d);
        const cs = getComputedStyle(d).color;       // "rgb(r, g, b)"
        document.body.removeChild(d);
        const m = cs.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        if (m) {
          const r = 255 - parseInt(m[1], 10),
                g = 255 - parseInt(m[2], 10),
                b = 255 - parseInt(m[3], 10);
          return `rgb(${r}, ${g}, ${b})`;
        }
        return '#fff';  // fallback blanc
      }

      // Nombre de colonnes¬†: largeur physique √∑ taille de police
      let columns = Math.floor(canvas.width / fontSize);
      let drops = Array(columns).fill(1);
      let dropColors = Array(columns).fill(0).map(_ => Math.random() * 360 | 0);

      let paused = false;
      let funkyMode = 0;
      const funkyBtn = document.getElementById('funky-btn');
      funkyBtn.onclick = () => {
        funkyMode = (funkyMode + 1) % 3;
      };


      /* ----------  Limiteur FPS (‚ö°)  ---------- */
      const MAX_FPS      = 30;                    // images/sec quand limit√©
      const FRAME_DELAY  = 1000 / MAX_FPS;
      let   lastTime     = 0;
      let   fpsCapEnabled = true;                 // cap actif par d√©faut
      
      const fpsBtn = document.getElementById('fps-btn');
      fpsBtn.onclick = () => { fpsCapEnabled = !fpsCapEnabled; };

      function resize() {
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
        columns = Math.floor(canvas.width / fontSize);
        drops   = Array(columns).fill(1);
        dropColors = Array(columns).fill(0).map(() => Math.random() * 360 | 0);
        // r√©-initialise aussi les buffers si resize
        buffers.length = 0;
        baseSat.length = baseLum.length = 0;
        idStreams.length = idIndices.length = 0;
        for (let i = 0; i < columns; i++) {
          buffers.push(Array(TAIL).fill(' '));
          baseSat.push(80 + Math.random()*20);
          baseLum.push(50 + Math.random()*30);
          idStreams.push(ulid());
          // idem au resize : index al√©atoire pour chaque nouvelle colonne
          idIndices.push(Math.floor(Math.random() * idStreams[idStreams.length - 1].length));
        }
      }
      window.addEventListener("resize", resize);

      /* ------------------------------------------------------------------ *
        * Rendu ‚Äúfull redraw‚Äù (aucun r√©sidu)                                 *
        * ------------------------------------------------------------------ */

      /** 1. Efface tout avec la vraie couleur de fond du th√®me courant */
      function clearBackground() {
        // utilise la couleur d√©j√† pr√©-lue
        // const bg = bgColor;
        ctx.save();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1;
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      }

      /** 2. Longueur de la tra√Æne (en caract√®res) ‚Äî ajuste √† ton go√ªt */
      const TAIL = 52;

      /* D√©cr√©ment lin√©aire d‚Äôopacit√© : 1, 1-1/TAIL, ‚Ä¶ 0 */
      const ALPHA = new Float32Array(TAIL);
      for (let i = 0; i < TAIL; i++) ALPHA[i] = 1 - i / TAIL;
      
      // ‚îÄ‚îÄ 3. Buffers pour la tra√Æne + saturation/luminosit√© + ULID streams ‚îÄ
      const buffers    = Array.from({ length: columns }, () => Array(TAIL).fill(' '));
      const baseSat = Array(columns).fill(0).map(() => 80 + Math.random()*20);
      const baseLum = Array(columns).fill(0).map(() => 50 + Math.random()*30);
      // Pour chaque colonne, on g√©n√®re un ULID initial...
      const idStreams = Array.from({ length: columns }, () => ulid());
      // ...et on positionne l‚Äôindex de d√©part de fa√ßon al√©atoire dans ce ULID
      const idIndices = idStreams.map(s => Math.floor(Math.random() * s.length));

      /** 3. Rendu complet d‚Äôune frame */
       function draw() {

        clearBackground();                            //‚úîÔ∏è plus de halo

        ctx.font = fontSize + "px monospace";

        for (let i = 0; i < columns; i++) {

          // ‚îÄ‚îÄ extrait le caract√®re suivant du ULID de cette colonne
          const stream   = idStreams[i];
          const idx      = idIndices[i] % stream.length;
          const headChar = stream[idx];
          idIndices[i]++;   // incr√©mente pour la prochaine frame
          buffers[i].unshift(headChar);
          if (buffers[i].length > TAIL) buffers[i].pop();

          const headHue = dropColors[i];
          // on r√©utilise la couleur de texte d√©j√† lue dans updateThemeColors()
          const baseColor = textColor;

          /* ‚Äî‚Äì‚Äì‚Äì‚Äì  tra√Æne  ‚Äì‚Äì‚Äì‚Äì‚Äî */
          for (let t = 0; t < TAIL; t++) {
            const row = drops[i] - t;
            if (row < 0) break;

            const y = row * fontSize;
            const x = i   * fontSize;

            /* Opacit√© d√©croissante‚ÄØ: 1 ‚Üí 0 */
            ctx.globalAlpha = ALPHA[t];

            // ‚îÄ‚îÄ D√©termine la couleur √† afficher ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let color;
            if (t === 0) {
              // t√™te brillante : couleur inverse du fond
              color = invBgColor;
            } else {
              if (funkyMode === 1) {
                // Funky 1 : couleur enti√®rement al√©atoire
                color = `hsl(${Math.random()*360|0},100%,60%)`;
                } else if (funkyMode === 2) {
                  // variation par colonne : petit delta chaque frame
                  const delta = (Math.random()*2 - 1) * 15;    // ¬±15‚ÄØ%
                  const sat   = Math.min(100, Math.max(0, baseSat[i] + delta));
                  const lum   = Math.min(100, Math.max(0, baseLum[i] + delta));
                  color = `hsl(${headHue}, ${sat}%, ${lum}%)`;
              } else {
                color = baseColor;
              }
            }
            ctx.fillStyle = color;

            const ch = buffers[i][t];  // on r√©affiche depuis le buffer
            // on teinte directement chaque glyphe
            ctx.fillText(ch, x, y);
          }

          ctx.globalAlpha = 1;                         // r√©initialise

          /* Re‚Äëcycle la colonne quand elle sort de l‚Äô√©cran */
          if ((drops[i] - TAIL) * fontSize > canvas.height && Math.random() > 0.975) {
            // ‚Üí nouvelle goutte : reset position, couleur, buffers et ULID
            drops[i]       = 0;
            dropColors[i]  = Math.random()*360|0;
            baseSat[i] = 80 + Math.random()*20;
            baseLum[i] = 50 + Math.random()*30;
            idStreams[i]  = ulid();   // nouvel ULID pour la colonne
            // position de d√©part al√©atoire pour briser les patterns
            idIndices[i]  = Math.floor(Math.random() * idStreams[i].length);
          }
          drops[i]++;
        }
      }

      // ‚îÄ‚îÄ Remplace le loop() par un tick() pour g√©rer le capping FPS ‚îÄ‚îÄ‚îÄ
      function tick(now) {
        if (!paused) {
          if (fpsCapEnabled) {
            // version limit√©e √† MAX_FPS
            if (now - lastTime >= FRAME_DELAY) {
              lastTime = now;
              draw();
            }
          } else {
            // version ‚Äúloop‚Äù sans limite : on dessine √† chaque frame
            draw();
          }
        }
        requestAnimationFrame(tick);
      }

      document.getElementById("pause-btn").onclick = () => paused = !paused;
      document.getElementById("funky-btn").onclick = () => funkyMode = (funkyMode + 1) % 3;

      // Gestion du plein-√©cran + masquage de la navbar
      const fsBtn = document.getElementById("fullscreen-btn");
      fsBtn.onclick = () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
        } else {
          document.exitFullscreen();
        }
      };
      document.addEventListener("fullscreenchange", () => {
        const nav = document.getElementById("nav-container");
        nav.style.display = document.fullscreenElement ? "none" : "";
      });
      
      /** Parse une couleur CSS (hex, rgb, hsl‚Ä¶) pour obtenir [r,g,b] */
      function parseRGB(col) {
        const d = document.createElement('div');
        d.style.color = col;
        document.body.appendChild(d);
        const cs = getComputedStyle(d).color;   // "rgb(r, g, b)"
        document.body.removeChild(d);
        const m = cs.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        return m ? [parseInt(m[1],10), parseInt(m[2],10), parseInt(m[3],10)] : [0,0,0];
      }

      // Mise √† jour de l‚Äôic√¥ne fullscreen selon le th√®me
      function updateThemeColors() {
        const s = getComputedStyle(document.documentElement);
        bgColor    = s.getPropertyValue('--matrix-background').trim();
        textColor  = s.getPropertyValue('--text').trim();
        // 1) met √† jour le fond du canevas en inline style‚Ä¶
        canvas.style.backgroundColor = bgColor;
        // ‚Ä¶puis le rend visible
        canvas.style.visibility = 'visible';
        // 2) calcule la couleur inverse pour la t√™te brillante
        invBgColor = invertColor(bgColor);
        // ‚Üí Calcule un fond transparent bas√© sur bgColor
        const [r, g, b] = parseRGB(bgColor);
        const helpBg     = `rgba(${r}, ${g}, ${b}, 0.6)`;
        // Applique en CSS variable‚Ä¶
        document.documentElement.style.setProperty('--help-bg', helpBg);
        // ‚Ä¶et en inline pour forcer la mise √† jour si n√©cessaire
        document.getElementById('help-box').style.backgroundColor = helpBg;
        // üî≥ ou üî≤ selon dark/light
        const theme = document.documentElement.getAttribute("data-theme");
        fsBtn.textContent = theme === "dark" ? "üî≥" : "üî≤";
        // synchronise la couleur de la bo√Æte d‚Äôaide
        document.documentElement.style.setProperty('--help-color', invBgColor);
      }

      // 3) r√©agir aux changements de th√®me (data-theme sur <html>)
      new MutationObserver(muts => {
        for (const m of muts) {
          if (m.attributeName === 'data-theme') {
            updateThemeColors();
          }
        }
      }).observe(document.documentElement, { attributes: true });

      updateThemeColors();
      requestAnimationFrame(tick);
      
      // ‚îÄ‚îÄ Opacit√© √† 1 pendant appui Ctrl gauche ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      document.addEventListener("keydown", e => {
        if (e.code === "ControlLeft") {
          document.querySelectorAll(".controls button").forEach(b => b.style.opacity = "1");
        }
      });
      document.addEventListener("keyup", e => {
        if (e.code === "ControlLeft") {
          document.querySelectorAll(".controls button").forEach(b => b.style.opacity = "");
        }
      });

      // ‚îÄ‚îÄ Bouton Aide ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const helpBtn = document.getElementById('help-btn');
      const helpBox = document.getElementById('help-box');
      helpBtn.onclick = () => {
        helpBox.style.display = helpBox.style.display === 'block' ? 'none' : 'block';
      };

      // ‚îÄ‚îÄ Raccourcis clavier ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      document.addEventListener('keydown', e => {
        // ignorer si on saisit dans un champ
        if (e.target.tagName === 'INPUT' || e.target.isContentEditable) return;
        switch (e.key) {
          case 'f': case 'F':
            fsBtn.click();
            break;
          case ' ':
            e.preventDefault();
            document.getElementById('pause-btn').click();
            break;
          case 'm': case 'M':
            document.getElementById('funky-btn').click();
            break;
          case 's': case 'S':
            document.getElementById('fps-btn').click();
            break;
          case 'h': case 'H':
            helpBtn.click();
            break;
        }
      });

    </script>

  </main>

  <footer>ULID Playground ‚Ä¢ Cod√© avec üíö par Rapha√´l et ü§ñ ‚Ä¢ Licence MIT</footer>

  <!-- enfin ton script principal -->
  <script type="module" src="./site.js"></script> 

</body>
</html>
